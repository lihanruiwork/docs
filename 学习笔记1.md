React vue 相似点
虚拟dom
响应式&组件化
React：某个组件的状态发生变化，会以该组件为根，重新渲染整个组件子树
需要PureComponent&shouldComponentUpdate
React
React有jsx，vue没有
Jsx：html&js混写
以<开头的，html规则解析
遇到{  ,js规则解析
{arr} 展开数组的所有成员
生成组件(首字母必须大写): createClass({
	render: function(){
		return <h1>…
	}
})
组件类只能包含一个顶层标签
this.props
this.props.children  组件的所有子节点  最好不用 可能undefined、object、array
最好用React.Children
React.PropTypes
React.createClass({
  propTypes: {
    title: React.PropTypes.string.isRequired,
  },
  getDefaultProps:funciton(){
return {title:’’}
}
	render: function() {}
}
获取真实dom节点
Vue原理
每个vue实例在被创建时经过一系列初始化过程，设置数据监听、编译模板、将实力挂载dom、在数据变化时更新dom
一个组件一个vue实例
生命周期钩子
beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy detroyed
vue响应式
Object.defineProperty
get 依赖收集
set 依赖更新
data的每个属性都拥有一个专属的依赖收集器subs
subs里面保存的是watcher，watcher就是组件实例的watcher
watcher用于视图更新
watch:
watch的watcher在对应数据的依赖收集器里
你设置的handler放在watcher的更新函数中
js对象  传入  vue实例的data，vue将遍历这个对象所有的属性，并使用Object.defineProperty 将这些属性全部转为getter setter
IE8不支持defineProperty

CSS操作：
div.setAttribute("style","background-color:red;"); div.getAttribute("style"); div.removeAttribute("style");
Style对象：div.style
div.style.width
Style对象的cssText属性能够读写document整个样式
div.style.cssText; //background-color: red;
带不带连字符都行
div.style["backgroundColor"]
div.style["background-color"]
如果设置了该属性，返回属性值
如果没设置该属性，返回空串
如果当前浏览器不支持该属性，返回undefined
div.style.backgroundColor 
Css模块的侦测：
typeof div.style.width==="string"
Css模块的侦测把不同浏览器的CSS规则前缀也考虑进去
function isPropertySupported(property){
  if (property in document.body.style) return true;
  var prefixes = ['Moz', 'Webkit', 'O', 'ms', 'Khtml'];
  var prefProperty=property.charAt(0).toUpperCase() + property.substr(1);
  for(var i = 0; i < prefixes.length; i++){
    if((prefixes[i] + prefProperty) in document.body.style) 	return true;
  }
  return false;
}
isPropertySupported('background-clip')// true
Style对象的三个方法 
setProperty getPropertyValue removeProperty
浏览器最终计算出的样式规则
window.getComputedStyle(div).backgroundColor;//rgb(255,0,0)
window.getComputedStyle(div).getPropertyValue(“height”)
//200px
由getComputedStyle计算返回的CSS值都是绝对单位，长度都是像素单位（px后缀），颜色是rgb(#, #, #)或rgba(#, #, #, #)格式。
DOM节点的style对象无法读写伪元素的样式，要用到window对象的getComputedStyle
getComputedStyle可接受第二个参数 当前节点的伪元素
window.getComputedStyle(div,":after").content;
window.getComputedStyle(div,":after").getPropertyValue("content");
StyleSheet对象：代表网页的一张样式表
document.styleSheets 网页中所有StyleSheet对象
document.styleSheets[0]==document.querySelector("style").sheet
<link><style>节点的sheet属性也为stylesheet对象
StyleSheet对象的属性：
media :screen屏幕 print打印 all
stylesheet.media.mediaText  //all
2.disabled:打开或关闭一张样式表
3.href title type
6.parentStyleSheet 包含当前样式表的那张样式表
@import在样式表中加载其他样式表
ownerNode:stylesheet对象所在的DOM节点，通常为link或style
8.cssRules 当前样式表中的规则,类似数组
sheet.cssRules[0].cssText
//body { background-color: red; margin: 20px; }
sheet.cssRules[0].style.color
在当前样式表的cssRules对象插入CSS规则
sheet.insertRule(“#block{color:white;}”,插入位置索引);
sheet.deleteRule(1);
添加样式表：
1.内置样式表 <style>
var style = document.createElement(style);
style.setAttribute(“media”,”screen”);
style.innerHTML=”body{color:red;}”;
document.head.appendChild(style);
2.外部样式表 <link>
var link = document.createElement(link);
link.setAttribute(“rel”,”stylesheet”);
link.setAttribute(“href”,””);
document.head.appendChild(link); 
Css规则：
cssRule接口的属性：
1.cssText 
2.parentStyleSheet 定义当前规则的样式表对象
3.parentRule 包含当前规则的CSS规则，比如当前规则包含在@media代码块中
4.type:当前规则的类型 1 3 4 5
样式规则       输入规则       Media规则     字体规则
cssStyleRule cssImportRule CSSMediaRule cssFontFaceRule 
一条CSS规则部署的接口：
1.CSSStyleRule接口
1.selectorText:当前规则的选择器  .myClass
2.style 样式声明 {}中的内容
2.CSSMediaRule接口 @media代码块
media：media规则

大括号内部的部分都是一个CSSStyleDeclaration对象
主要包括三部分：
HTML 元素的行内样式（<elem style="...">）
CSSStyleRule接口的style属性
window.getComputedStyle()的返回结果
styleObj = document.styleSheets[0].cssRules[1].style;
styleObj.color // "red";
CSSStyleDeclaration的其他属性和方法：
cssText length parentRule
getPropertyPriority(“color”):声明的优先级 important或空串
getPropertyValue(“color”) 
item(index) 指定位置的属性名
removeProperty(“color”) setProperty(“color”,”green”,”important”)
window.matchMedia方法用来检查CSS的mediaQuery语句
显示媒介（包括浏览器和屏幕等）满足mediaQuery语句设定的条件，就会执行区块内部的语句
@media all and (max-width:700px){
	body{
		background:#FFF;
	}
}
该区块对所有媒介有效，且视口最大宽度不得超过700px
mediaQuery接受两种宽度/高度的度量，视口和设备
max-width 视口  max-device-width:设备
视口用documentElement.clientWidth/clientHeight来衡量
设备用screen.width/height来衡量
result=window.matchMedia(“(min-width:600px)”)
返回一个mediaQueryList对象
result.media  //返回所查询的mediaQuery语句字符串
result.matches  //布尔值，表示当前环境是否匹配查询语句。
result.addListener(mqCallBack)
result.removeListener(mqCallBack)
回调函数的参数 MediaQueryList对象
CSS事件：
1.Transition效果结束后，触发transitionEnd事件
Event的属性：
propertyName:发生transition效果的css属性名
elapsedTime：transition效果持续的秒数
pseudoElement：如果发生在伪元素，返回伪元素的名称，以::开头
2.animationstart 动画开始 animationend 动画结束 animationiteration 开始新一轮动画循环时触发
他们仨都有 event.animationName event.elapsedTime
HTTP2:
头信息和数据体都是二进制
复用TCP连接
客户端和浏览器 同时发送多个请求或回应，而且不用按照顺序，避免队头堵塞
数据流
同一个连接里面连续的数据包，可能属于不同的回应。
每个请求或回应的所有数据包，称为一个数据流
每个数据流都有一个独一无二的编号
客户端奇数，服务器偶数。
数据流发送到一半的时候，客户端和服务器都可以发送信号取消这个数据流。
HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。
4.头信息压缩
头信息压缩后再发送
客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号
不发送同样字段了，只发送索引号，这样就提高速度
服务器推送
严格模式
不合理、不严谨、不安全之处
提高编译器效率，增加运行速度；
新版本 JS 铺垫。
正常模式下可以运行的语句，严格模式可能不能运行。
use strict不在第一行，无效
函数体的第一行
前一个script标签是严格模式，后一个不是。
不利于文件合并，立即执行的匿名函数
　　(function (){ 　　　　"use strict";
　　　　// some code here 　　 })();
显式声明var
禁止with
eval本身就是一个作用域，生成的变量只能用于eval内部。
构造函数时忘加new，this不指向全局对象，报错。
不允许f1.caller f1.arguments
不允许对arguments赋值
arguments不再追踪参数的变化
禁止arguments.callee
禁止删除变量
只有configurable设置为true的对象属性，才能被删除。
对一个对象的只读属性（writable: false）进行赋值，报错。
对访问器属性赋值
重名：对象属性 函数参数
八进制
声明函数:全局作用域或函数作用域的顶层,非函数的代码块
新增保留字不能做变量名 let private public protected static  package yield implements interface 
this
this调用函数的那个对象
1.全局性调用，因此this就代表全局对象Global。
2.作为某个对象的方法调用,this就指这个对象
3.作为构造函数使用new调用，指新建的实例对象
4.apply调用，this指第一个参数
Display
display:none 将元素与其子元素从普通文档流中移除
visibility:hidden 依然占据原来的空间
display:inline 行内级元素/内联元素 宽度随元素的内容变化 width height属性无效 padding-left/right margin-left/right产生边距效果 竖直方向不会产生边距效果 
span a strong em label input select textarea img br 
display：block 独占一行 可以设置width height 可以设置margin padding
div form table p pre h1-h6 dl ol ul 
block元素可以包含block和inline元素，但inline元素只能包含inline元素
display:inline-block
将对象呈现为inline,之后的内联元素会被排列在同一行内，但内容作为block呈现，可以设宽度，高度等inline没有的属性
display:list-item 列表项呈现，可以被list-style属性进行样式修饰的标记框
基于表格的布局
display:table
display:table-header-group  <thead>
display:table-row-group     <tbody>
display:table-footer-group  <footer>
display:table-column-group  <colgroup>
display:table-row           <tr>
display:table-cell          <td>
display:table-column        <col>
display:table-caption       <caption>
display:inline-table        表现为表格HTML元素，但是是一个内联块而不是块级元素
display:flex 弹性盒子
flex容器属性：
flex-direction:row column row-reverse column-reverse
flex-wrap:nowrap wrap wrap-reverse 
flex-flow：前两个合并
justify-content：项目在主轴上的对齐方式
flex-start 、flex-end 、center 、space-between 、space-around
align-items：项目在侧轴对齐方式
flex-start 、flex-end 、center 、stretch、baseline
align-content：多行在容器中如何分布
flex-start、flex-end、center、stretch
flex项的相关属性：
order：flex项目根据order值重新排序 没order的放前面有order的放后面
flex-grow：默认0（不会扩展） 1会扩展填充可用空间
flex-shrink：空间不够，是否可缩小 默认1
flex-basis：指定项目初始大小 auto(基于内容的多少来自动计算) 150px(固定宽度) 比width优先级高
flex:前三个的合并
伸展度不一样：一个项目 flex-grow=1另一个项目 flex-grow=2  
前一个占1/3  后一个占2/3
align-self：改变一个弹性项目沿着侧轴的位置，而不影响相邻的弹性项目
flex-start flex-end center baseline stretch auto  
自动外边距：margin-right:auto 右边占据所有剩余空间
            margin:auto 两边分割剩余空间
有了自动外边距，justify-content 就不起作用了
Gradient
background:linear-gradient(to right ,red 10% , blue 20%);
background:repeating-linear-gradient(red 10% , blue 20%);
-webkit-linear-gradient safari
-o-linear-gradient opera
-moz-linear-gradient firefox
background:radial-gradient(red, green, blue);
background:radial-gradient(circle, red, green);
background:radial-gradient(ellipse, red, green);
Ajax
XMLHttpRequest对象用来在浏览器与服务器之间传送数据
XMLHttpRequest对象的属性：
1.readyState：
XMLHttpRequest请求当前所处的状态
0 open之前
1 open之后 send之前 
2 send之后 头信息和状态码已经收到 
3 正在接收body部分的数据
4 数据完全接收，或者本次失败了。
2.response数据体 
3.responseType 字符串text document json blob arraybuffer
overrideMimeType()
4.responseText 字符串 json
5.responseXML document
6.status HTTP状态码
readyState == 4 status >= 200 status < 300 status == 304
7.statusText
整个状态信息 200 OK
8.timeout
多少毫秒后，就会自动终止
xhr.ontimeout = function () {}
9.withCredentials
跨域请求是否发送Cookie
XMLHttpRequest对象的方法：
1.abort()
终止已经发出的HTTP请求。
2.getAllResponseHeaders()
3.getResponseHeader()
4.open(五个参数)
method：HTTP动词 GET POST PUT DELETE
url async请求是否异步
5.send()
实际发出HTTP请求
发送二进制数据，用ArrayBufferView或Blob,使得通过Ajax上传文件成为可能。
FormData 构造表单数据。
new FormData(form节点);
模拟File控件，进行文件上传 formData.append(file.name, file);
6.setRequestHeader()
open()后 send()前
XMLHttpRequest实例的事件：
事件监听接口:
onloadstart 请求发出
onloadend 请求完成，不管成果或失败
onload 请求成功完成
onerror 请求失败
onabort 请求被中止，比如用户调用了abort()方法
ontimeout 用户指定的时限到期，请求还未完成
readyStateChange readyState值每次变化或xhr.abort()
2.progress
不断返回上传的进度: xhr.upload.onprogress
不断返回下载的进度: xhr.onprogress
<progress>
xhr.upload.onprogress=function(){}
lengthComputable  loaded  total
progress节点.value=loaded/total*100
Canvas
<canvas width height></canvas>
绘画上下文 drawing.getContext(“2d”)
导出图像img.src=drawing.toDataURL(“image/png”)
原点坐标左上角
fillStyle strokeStyle fillRect clearRect
beginPath()
arc(x,y,半径，起始角度，结束角度，逆时针)
arcTo(x1,y1,x2,y2,半径):至(x2,y2)，以半径穿过(x1,y1)
bezierCurveTo(c1x,c1y,c2x,c2y,x,y)至(x,y)过c1 c2
lineTo(x,y) moveTo(x,y)
quadraticCurveTo(cx,cy,x,y):二次曲线到(x,y)，过(cx,cy)
rect(x,y,width,height):矩形路径
closePath():连接到路径起点
fill() stroke() clip()
isPointInPath(100,100) 路径被关闭之前 某一点是否位于路径上
fillText strokeText(内容，x,y,最大像素)
font textAlign(start end) textBaseline
measureText(内容).width
rotate(弧度) scale(缩放比例x y) 
translate(x,y)将坐标原点移动到x,y 
save() 保存设置 restore() 
drawImage(img,x,y)
drawImage(img,x,y,宽,高) 改变绘制后图像大小
drawImage(canvas,源x,源y,源宽,源高,x,y,宽,高)
shadowColor shadowOffsetX shadowOffsetY 阴影偏移量  
shadowBlur 模糊像素数
createLinearGradient(30,30,70,70)
createRadialGradient(x1,y1,半径1，x2,y2,半径2)
addColorStop(0/1,”white”)
context.fillStyle/strokeStyle=gradient;
createPattern(img/canvas/video,repeat/repeat-x/repeat-y/no-repeat);
context.fillStyle=pattern
getImageData(x,y,宽度,高度) 三个属性 width height data
data 数组，每一像素的数据
灰阶过滤 i+=4  data[i] data[i+1] data[i+2] /3
data[i]/data[i+1]/data[i+2]=average;
去掉颜色，保留亮度
putImageData(imageData,x,y);
canvas优化
1.离屏 Canvas:createElement('canvas')
不需要反复图片渲染
只要一个图，然后自适应 drawImage(canvas, 0, 0);
2.集中绘制 绘制操作 消耗资源
beginPath() 一堆操作 stroke()
不变的场景分离变化的物体
背景图置于canvas后
4.坐标点浮点数 浏览器额外的运算
Position
position:static 默认
position:relative 相对于元素本身位置进行定位
可以通过top left bottom right 设置元素的定位值  
元素最初所占的空间物理位置还是存在 
元素相对定位后并没有影响其他相邻的元素
position:absolute 整个元素飘出文档流 元素自身的物理空间也消失了 
一个元素绝对定位后，其参照物离自身最近的且position不是static的父元素，一直找到html为止。
position:fixed 相当于absolute 不过其包含块是视窗本身
float会改变正常的文档流排列，影响到周围元素。
浮动
浮动的三个特点很重要。
1. 脱离文档流。
2. 向左/向右浮动直到遇到父元素或者别的浮动元素。
3. 浮动会导致父元素高度坍塌。
存在盖住普通元素的风险。
防止浮动元素彼此覆盖。
相对于最近的块级祖先元素进行浮动
浮动元素的外边界不能超出其包含块的内边界
浮动元素的左边界是先出现的左浮动元素的右边界，除非元素的顶端在先出现浮动元素的底端下面
浮动元素不能比之前所有浮动元素或块级元素的顶端更高
不占据文档流的位置，自然父元素也就不能被撑开，所以没了高度
解决父元素高度坍塌的方式就是清除浮动
clear清除浮动和BFC清除浮动
如何清除浮动：
1.在浮动元素末尾添加一个空元素，也可以用伪元素的形式 设置clear:both 确保一个元素旁边没有浮动元素
2.在父元素触发BFC来闭合浮动，因为BFC会包含浮动
float除了none以外的值
overflow除了visible以外的值
display:inline-block table
position:absolute fixed
BFC 块级格式化上下文 CSS3中叫Flow Root
创建了BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素
BFC:
不属于同一个BFC块级元素外边距不会发生叠加
包含浮动
还有一个不想记了
垃圾收集
Javascript自动垃圾收集机制
找出那些不再继续使用的变量，释放其占有的内存
垃圾收集器会按照固定的时间间隔周期性的执行这一操作
IE7以前：根据内存分配量达到临界值，垃圾收集器就会运行
最大的问题是，如果一个脚本包含这么多变量，很可能在其生命周期中一直有这么多变量，垃圾收集器会频繁的运行，引发严重性能问题 
IE7以后，如果回收的内存低于15%，变量，对象字面量，数组的临界值加倍，如果回收的内存高于85%，临界值重置会默认值
1.标记清除
垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记
然后去掉环境中的变量，以及被环境中的变量引用的变量的标记
那么剩下的被标记的变量就是准备删除的变量
最后垃圾收集器完成内存清除工作，销毁值并回收他们占用的内存空间
2.引用计数 
变量 对象字面量 数组
跟踪记录每个值被引用的次数
当一个值的引用次数变为0时，就将其占用的内存空间回收回来
有问题，循环引用
两个对象相互引用 永远也不会被回收
怎么解决，手工断开他们之间的连接，将变量设为null,切断变量与值之间的连接，当垃圾收集器下次运行时，就会删除这些值并回收他们占用的内存。
局部变量会在他们离开执行环境时自动被解除引用
对于全局变量和全局对象的属性：为执行的代码只保存必要的数据，一旦数据不再有用，将其设置为null释放其引用
不再用到的内存，没有及时释放，叫做内存泄露
实时查看内存占用
如果内存占用基本平稳，接近水平，就说明不存在内存泄漏
及时清除引用很重要，但有时你会忘
ES6两种新的数据结构：WeakMap WeakSet
对值的引用不计入垃圾回收机制 
相当于声明那些引用可以忽略不计，其他引用消失以后，垃圾回收机制就可以释放内存。减轻程序员负担
HTTP状态码
1XX 请求正在处理
2XX 请求正常处理完毕
200 请求被成功处理
204 服务器不需要返回响应体，浏览器显示的页面不会发生更新。
3XX 重定向状态码，表示需要客户端需要进行附加操作，浏览器需要执行某些特殊的处理以完成请求。
301 永久性重定向。
请求的资源已经被分配了新的URI，以后使用资源现在所指的URI。
根据请求的方法有不同的处理方式： HEAD：响应头部Location字段中指明新的永久性的URI。 GET：在响应体中附上永久性URI的超链接文本。 POST：让用户确认跳转。
如果一个URI已经在浏览器中被收藏为书签，这时应该按照Location首部字段提示的URI重新保存。
302 临时性重定向
请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问。资源不是被永久移动，只是临时性质的
302响应是不会像301那样去更新书签。
302指定使用原有请求方法
303 临时重定向 指定使用GET方法
307 临时重定向，并不会指定客户端要用什么样的请求方法请求重定向地址。
4XX 客户端错误，客户端是发生错误的原因所在
400 请求报文中存在语法错误，导致服务器无法理解该请求。
客户端需要修改请求的内容后再次发送请求。
401 发送的请求需要有通过HTTP认证的认证信息。
响头部 WWW-Authenticate 指明服务器需要哪种方式的认证。
当客户端再次请求该资源的时候，在请求头Authorization包含认证信息。
403 被服务器拒绝
404 服务器上无法找到指定的资源
5XX 服务器错误
500 服务器端在执行请求时发生了错误
501 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。
502 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。
503 服务器暂时处于超负载或正在进行停机维护
JS隐式类型转换
自动转换的规则：预期什么类型的值，就调用该类型的转换函数。
1.自动转换为布尔值
当JavaScript遇到预期为布尔值的地方（比如if语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用Boolean函数。
除了以下六个值，其他都是自动转为true。
undefined、null、-0、0或+0、NaN、''（空字符串）
将一个表达式转为布尔值
// 写法一  expression ? true : false
// 写法二  !! expression
2.自动转换为字符串
字符串的自动转换，主要发生在加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。
3.自动转换为数值
除了加法运算符有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。
一元运算符也会把运算子转成数值。
+'abc' // NaN
-'abc' // NaN
+true // 1
-false // 0
对操作顺序非常敏感
1 + 2 + "3"; // "33"
isNaN()方法自带隐式类型转换,在测试其参数之前，会先调用Number()方法将其转换为数字
条件判断使用全等运算符===,会先进行数据类型判断，并且不会发生隐式类型转换。
由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String函数进行显式转换。
从输入url到页面展示:
首先输网址，输的时候浏览器就只能匹配给你补全网址，从历史记录啊，书签啥的。
发起请求了，根据域名查一下它对应的IP,先去本地hosts查有没有匹配域名的IP,有就用，没有就上DNS服务器查去。
域名分好几层呢，根域名 顶级域名 次级域名 主机名
根域名服务器IP地址一般都给定了，直接向这些IP地址发请求，查顶级域名的服务器地址
查着以后，把最先回复的根域名服务器IP地址存上，以后就找他了，谁让他最积极呢。
再向查着的顶级域名服务器地址发请求，查次级域名服务器地址
查着以后在向次级域名服务器地址发请求，查主机IP
一般都会查着好几个
你每次查的域名服务器地址都能查着好几个，为啥呢，为了防止单点失败，一个没了，别的还好使，学名叫DNS负载均衡。
有时候用户太多，都访问一个服务器受不了，就多弄几个IP地址，多几个IP就是多几个服务器，大家都分担一下
现在我们拿着IP了哈
随机分个端口就发起TCP连接请求了吼
端口0-1023都被系统占了，咱就只能占1024-65535
对方的端口一般都是80
Tcp连接建立完了，就可以发http请求了
且慢，咱们捋一捋Tcp连接吧
Tcp就是为了传数据，
先建立连接三次握手，然后就开始传数据，最后把连接关了四次挥手
三次握手
咱们先把主动发起连接请求的一方叫客户端，被动等待连接建立的一方叫服务器
第一次握手：客户端SYN=1 seq=J 发给服务器，进入SYN_SEND状态
第二次握手：服务器收到了，把SYN和ACK都置为1，ack=J+1,seq=K,发给客户端，确认同意连接，自己进入SYN_RCVD状态
第三次握手：客户端收到人家确认的请求了，检查ack是不是J+1，ACK是不是1，确认完了，以后ACK=1,ack=K+1发给服务器。服务器一检查发现数据对，连接就建立成功了。
这时候两方都进入到ESTABLISHED状态。大家就可以开始传数据了
为啥非要三次握手：
假如网络卡了，客户端发的连接请求没传给服务器，过了好久，这个连接请求终于发给了服务端，这时客户端已经不想再连接了。但是服务器不知道啊，服务器就同意了这次连接，如果没有第三次握手，服务器就一直傻等，白白浪费自己的资源等待接收客户端给他传的数据
建立了TCP连接之后，发起一个http请求
再说说四次挥手：
TCP 的连接是全双工（可以同时发送和接收）的连接，因此在关闭连接的时候，必须关闭传送和接收两个方向上的连接。 客户端给服务器发送一个携带 FIN 的 TCP 结束报文段，然后服务器返回给客户端一个 确认报文段，同时发送一个 结束报文段，当客户端回复一个 确认报文段 之后，连接就结束了。
释放连接过程
在结束之前，通信双方都是处于 ESTABLISHED 状态，然后其中一方主动断开连接。 下面假如客户端先主动断开连接。
第一次挥手： 客户端向服务器发送结束报文段，然后进入 FIN_WAIT_1 状态。 此报文段 FIN = 1， Sequence Number = M。
第二次挥手： 服务端收到客户端的结束报文段，然后发送确认报文段，进入 CLOSE_WAIT 状态。 此报文段 ACK = 1， Sequence Number = M + 1。
客户端收到该报文，会进入 FIN_WAIT_2 状态。
第三次挥手： 同时服务端向客户端发送结束报文段，然后进入 LAST_ACK 状态。 此报文段 FIN = 1，Sequence Number = N。
第四次挥手： 客户端收到服务端的结束报文段，然后发送确认报文段，进入 TIME_WAIT 状态，经过 2MSL 之后，自动进入 CLOSED 状态。 此报文段 ACK = 1, Sequence Number = N + 1。
服务端收到该报文之后，进入 CLOSED 状态。
关于 TIME_WAIT 过渡到 CLOSED 状态说明： 从 TIME_WAIT 进入 CLOSED 需要经过 2MSL，其中 MSL 就叫做 最长报文段寿命（Maxinum Segment Lifetime），根据 RFC 793 建议该值这是为 2 分钟，也就是说需要经过 4 分钟，才进入 CLOSED 状态。
为什么不立刻closed:俩原因
万一服务器没收到ACK,会向客户端再次发送请求，但是客户端已经closed,就会报错。
假如立即closed,然后又建立了一个连接，分的端口号又恰巧跟上次一样，又恰好上次连接还有一些数据滞留了，这次发过来了，那么作废的数据和有用的数据万一有重名，就出问题了。所以多等一会，让本次连接的所有数据都从网络中消失。
实体层 链接层 网络层 传输层 应用层 
终于说完了。
我们把HTTP数据包塞进TCP数据包，TCP数据包标头是己方端口（随机）和服务器端口80，TCP数据包塞进IP数据包，IP数据包标头是发送方和接收方IP地址，IP数据包塞进以太网数据包，以太网数据包标头双方的MAC地址，再上层就是物理层了，01信号在电缆光缆双绞线中传啊传
咋知道接收方的MAC地址（网卡地址）：用IP地址根据ARP协议得到
如果在同一个子网，用ARP协议，向子网内所有主机发数据包，每个主机自己比较数据包里的IP跟自己一不一样，不一样丢弃，一样就返回自己的MAC地址。

数据包主要是一个网卡传向另一个网卡。
先看是不是在同一个子网，广播发送数据包，根据MAC地址确认自己是不是接收方。
如果不在同一个子网，就把数据包给网关，让网关去处理
以太网数据包最大1500字节，IP数据包如果过大就切割成几个包发送，把每个包编上号。
目标主机收着数据包了，操作系统组装还原数据包，TCP给每个包都编了号seq，每个数据包都有两个编号自身编号和下一个包的编号。
操作系统组装好了就根据端口发给应用程序
TCP慢启动机制，建立完连接开始发包，一开始发的特别慢，根据丢包情况调整速率，接收方每收到两个数据包就发一个ACK,ACK包含期待的下一个数据包编号和接受窗口容量。如果下一个期待的数据包没有收到，ACK中的编号不会变，发现收到三个重复的ACK,确认丢包，从而再次发送这个包。
由此得到完整的TCP数据包，取出其中的HTTP请求。
反向代理：一些网站访问量太大，就会将http请求先发到反向代理服务器中，将这些请求分发给多台机器处理。
服务器处理完请求给个HTTP响应，这个响应也是通过TCP协议发回来。
收到了http响应就可以将页面显示出来了，网络通信就是这么个流程。
网页咋渲染的：
HTML代码转化为DOM
CSS代码转化为CSSOM
结合DOM和CSSOM生成一棵渲染树
重排也就是生成布局
重绘就是把布局绘制在屏幕上

导致网页性能下降的根本原因：不断地重排和重绘
什么会导致网页重新渲染：
DOM变了 CSS变了 鼠标悬停页面滚动等事件
我们要怎么提高网页性能：尽量少触发网页重新渲染
浏览器还是很智能的，他会尽量把变动放在一起，一起渲染。
但是一些读操作会引起浏览器立即重新渲染。
offsetHeight offsetWidth offsetLeft offsetTop
scrollHeight scrollWidth scrollLeft scrollTop
clientHeight clientWidth clientLeft clientTop
getComputedStyle()

所以咱们尽量把读操作写一起，写操作写一起
别一行读，一行写，一行读，一行写
还有
Table重排和重绘的成本比div高，这就是为啥老说让少用table
DOM层级越高重排重绘成本越高
样式表越简单重排重绘成本越小
DocumentFragment特别不错，对它操作不会影响现有的页面布局
同样原理，cloneNode()
把他俩操作完了再一次性插到页面里
Position是absolute或fixed重排开销小，因为他俩对别的元素没影响
先将元素值为display:none在对他进行100此操作，最后再恢复它，相当于用两次渲染代替100次渲染

别一条条写样式，用className或者cssText,一次性多改变样式。

有时候密集的重新渲染不可避免，比如scroll事件或者动画
用requestAnimationFrame()将重新渲染和显示器刷新频率同步，避免多次渲染但是显示器根本来不及显示这种变化，达到最佳视觉效果。
Attribute
元素对象独有，Element.attributes 类似数组的动态对象
Element.attributes[0].name=Element.attributes[0].nodeName
Element.attributes[0].value=Element.attributes[0].nodeValue
标准属性自动转为节点对象的属性
delete f.action：不会生效
Html元素的属性名大小写不敏感,Javascript敏感
转为js属性名时一律小写
如果包含多个单词，采用骆驼拼写法，从第二个单词开始首字母大写
元素节点的操作属性的四个方法：
getAttribute
setAttribute
hasAttribute
removeAttribute
自定义属性：data-**  元素节点.dataset.**
通过dataset.foo读写data-foo属性
删除属性：delete 元素节点.dataset.foo
dataset.helloWorld会转成data-hello-world
data-后面的属性名有限制，只能包含字母、数字、连词线（-）、点（.）、冒号（:）和下划线（_)。而且，属性名不应该使用A到Z的大写字母
文字换行
overflow:auto/hidden
word-wrap:
normal 英文内容可以冲破容器，中文会换行 
break-word 内容在边界换行，不截断英文单词
word-break:
normal 
break-all截断英文 
keep-all汉字短语/英文单词整个换行
对于长串的英文单词,最好是行内换行而不应该是词内换行
word-wrap:break-word;
overflow:hidden;

Sql server分页 int firstResult=(pageNo-1)*maxResults;
Hibernate SQLQuery
sqlQuery.setFirstResult(firstResult);
sqlQuery.setMaxResults(maxResults);
select * from table limit m,n n是指从第m+1条开始，取n条

struts咋配的
web.xml 配一下
struts.xml <include file=“”></include>
package action result 

var length = !!obj && "length" in obj && obj.length;
闭包
有权访问另一个函数作用域中的变量的函数
在一个函数内部创建另一个函数
内部函数的作用域链包含外部函数的作用域
在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，直至作为作用域链终点的全局执行环境。
读取或写入变量的值时，在作用域链中查找变量。
一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局执行环境的变量对象。
内部函数会将外部函数的活动对象添加到它的作用域链中。
外部函数执行完毕后，其执行环境的作用域链会被销毁，但其活动对象仍然留在内存中，因为内部函数的作用域链仍然在引用这个活动对象。
使用闭包内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题。
在退出包含函数后把所有不用的活动对象设为null，确保内存回收
闭包可以改变函数内部的值，这一点要注意。
闭包可能会引起内存泄漏
function f1(){
　　var n=999;
　　function f2(){ 　　　　alert(n);  　　}
　　return f2;
}
var result=f1();
result(); // 999
f2就是一个闭包
浏览器内核
浏览器内核又可以分成两部分：
渲染引擎 JS引擎
渲染引擎：获取html、图像等，加入CSS，计算网页的显示方式，输出至显示器。
JS引擎：解析JavaScript语言，实现网页的动态效果。
目前内核倾向于只指渲染引擎。
常见的浏览器内核:Trident Gecko Blink Webkit
Trident:IE
Gecko:Firefox
Webkit:Safari Chrome
TextArea
高度不能自适应，所以要用div
显摆它的滚动条，高度固执地岿然不动。
div的高度自适应性
<div contenteditable="true"></div>
width: 400px; min-height: 120px; max-height: 300px; outline: 0; border: 1px solid #a0b3d6; -webkit-user-modify: read-write-plaintext-only; overflow-y: auto;
要进行HTML字符过滤。
如果不设成只显示纯文本，回车会造成输入好几个子div，每个div里都有一个<br>
还可以这么设纯文本
<div contenteditable="plaintext-only"></div>
各大排序算法：
1.冒泡排序：O(n^2)
依次比较相邻的两个数，调换顺序
对除了最后一个之外的数重复第一步，直至只剩一个数
每次都把最大的数排好
for(var i=0;i<length-1;i++){    for(var j=0;j<length-i-1;j++){        if(array[j]>array[j+1]){            swap(array,j,j+1);        }    } }
2.选择排序：O(n^2)
1.找出最小的数和第一个数交换位置
2.在剩下的数中，找出第二小的数放在第二个
for(var i=0;i<length-1;i++){     var min=i;     for(var j=i+1;j<length;j++){         min=array[min]<array[j]?min:j;     }     swap(array,min,i); }
3.插入排序：O(n^2)
从未排中抽出一个数和已排序部分比较，插入到合适的位置
for(var i=0;i<length;i++){     var temp=array[i];     for(var j=i-1; j>=0&&array[j]>temp;j--){         array[j+1]=array[j];     }     array[j+1]=temp; }
4.合并排序：O(nlogn)
function guibing(array){     if(array.length<2){         return array;     }else {         var mid = array.length / 2;         var left = array.slice(0, mid);         var right = array.slice(mid, array.length);         return merge(guibing(left),guibing(right));     } } function merge(left,right){     var res=[];     var i=0;     var j=0;     while(i<left.length&&j<right.length){         if(left[i]<right[j]){             res.push(left[i++]);         }else{             res.push(right[j++]);         }     }     return res.concat(left.slice(i)).concat(right.slice(j)); }
5.快排：O(nlogn)
以一个数为基准，比他小的放左边，比他大的放右边
function kuaipai(array){     if(array.length<2){         return array;     }     var mid=array.length/2;     var left=[];     var right=[];     var val = array.splice(mid,1);     for(var i=0;i<array.length;i++){         if(array[i]<val){             left.push(array[i]);         }else{             right.push(array[i]);         }     }     return kuaipai(left).concat(val,kuaipai(right)); }
稳定：冒泡，插入，归并
不稳定：选择，快排

Event Loop
Javascript运行环境的运行机制：只要主线程空了就去读任务队列
任务队列你在主线程上的一切调用
使用事件驱动的系统中必然有非常非常多的事件。
不同的事件放置在不同的队列
当我们进行定时器调用时，会设置一个定时器watcher。
对某类事件不关心时则没有相关watcher
产生事件后，这个事件会被放进队列中等待被处理。
事件循环时调用这个watcher,检查他的事件队列上是否产生事件
检查完所有watcher后，进入下一轮检查
同步就是调用之后一直等待，直到返回结果。
异步则是调用之后，不能直接拿到结果，通过一系的手段才最终拿到结果,调用之后，拿到结果中间的时间可以介入其他任务。
所谓事件驱动，就是将一切抽象为事件（io操作，用户点击，Ajax,图片加载）
异步任务不一定要回调函数
主线程永远在执行，并不断检查事件队列
事件驱动的实现过程主要靠事件循环来完成。
进程启动后就进入主循环
主循环不停地从事件队列里读取事件
一般事件是靠底层系统或者线程池之类的产生事件，但定时器事件是靠事件循环不停检查系统时间来判定是否到达时间点来产生事件
变量提升
解析器率先读取用var声明的变量和function声明的函数，将它们提升到代码的头部。
对于函数，使其在任何代码之前都可用。
对于变量，即使在声明变量的语句之前调用该变量，也不会报错，只会显示undefined。
var和function声明的全局变量，依旧是顶层对象window的属性
let const class 声明的全局变量，不是顶层对象window的属性
Let声明的变量只在代码块内有效。
let不允许在相同作用域内重复声明
for(let i=0)
每一次循环的i都是一个新的变量
a[6]=6; 
for(父作用域){
子作用域
}
for(let i=0;i<3;i++){
let i=”abc”;
console.log(i);
}
//abc abc abc
let命令声明的变量一定要在声明后使用，否则报错
在块级作用域内let声明的变量绑定这个区域，不再受外部的影响
在声明前使用变量就会报错 
暂时性死区：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有声明了变量，才能获取和使用。
function func(arg){let arg;//报错}
function func(arg){{let arg;}}//不报错
let为js带来块级作用域，立即执行函数不用要了
const 一旦声明变量，必须立即初始化,声明的变量不得改变值
const只在声明所在的块级作用域内有效，变量不提升
Js数组去重
新建一个空数组，遍历原数组，新数组.indexOf(每一项值)==-1才push
新建一个空对象
把值和值类型传入这个空对象
遍历原数组，对象[val]如果不存在就push
如果存在就再判一下值的类型，因为对象[val]会把val转成字符串防止数组中“12”和12被当成同一个
速度快，占的内存大
遍历数组 判断一下array.indexOf(array[i])==i
看看数组的第i项值在数组中第一次出现的位置是不是i
HTTP缓存机制
客户端缓存的意义：将一些不经常变化的文件存储起来，优化用户浏览体验。
根据是否需要重新向服务器发起请求分类：
强制缓存
   响应header里有两个字段标明失效规则，Expires（HTTP 1.0）	和Cache-Control（HTTP 1.1）
   Expires:到期时间
下一次请求时，请求时间小于到期时间，直接使用缓存数据。	Expires使用的是服务端生成的事件，和客户端时间有误差。
 Cache-Control:private public 
max-age：缓存的内容将在多少秒后失效 
no-cache需要使用对比缓存来验证缓存数据
 no-store 所有内容都不会缓存
客户端向缓存数据库请求数据
有缓存数据，且未失效，返回数据
缓存数据失效，客户端向服务器请求数据，服务器返回数据和缓存规则。客户端将数据和缓存规则存入缓存系统。
有个文件可能时不时会更新一下，服务端希望客户端能时不时来问一下文件是否有更新，如果没有，服务端就不返数据给你，只返回一个状态码304。
对比缓存
客户端向缓存数据库获取缓存数据的标识，将这个标识发给服务器，请求服务器验证缓存标识对应的数据是否失效。
服务器通知客户端缓存未失效，客户端去缓存数据库获取缓存数据
数据失效，服务器返回最新数据和缓存规则，客户端将数据和缓存规则存入缓存数据库。
缓存标识：在请求header和响应header之间传递。有两种
Last-Modified  If-Modified-Since
服务器在响应中有LastModified,告诉浏览器资源的最后修改时间。
客户端请求服务器时，把这个值放在If-Modified-Since,服务器收到请求后，将其与被请求资源的最后修改时间对比。如果最后修改时间大于If-Modified-Since,说明资源被改动了，响应整片资源内容。，返回状态码200。如果资源的最后修改日期小于等于If-Modified-Since，说明资源无新修改，响应状态码304。
Etag If-None-Match
客户端第一次访问资源时，服务器返回Etag:1234,告诉客户端这个文件的标签是1234，如果修改了这个文件，这个标签就会不一样了。
下次访问资源时，客户端带上If-None-Match,告诉服务器如果那边的资源标签还是1234，就返回304，否则返回资源内容和200。
Etag很少有人用，他会用算法，占用服务器计算的资源。
强制缓存如果生效，不需要再和服务器发生交互。
对比缓存不管是否生效，都要和服务器发生交互。
两种缓存规则可以同时存在，强制缓存优先级别高于对比缓存，只要强制缓存生效了，就不用执行对比缓存了。
三种刷新：
浏览器中写地址，回车
强制缓存 最快
F5
客户端会发If-Modified-Since
Ctrl+F5
把缓存中的这个文件给我删了，重新去服务器请求个完整的资源文件下来。客户端完成了强行更新的操作。
CSS选择器
多元素的组合选择器：
E,F 多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔
E F 后代元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔
E > F 子元素选择器，匹配所有E元素的子元素F
E + F 毗邻元素选择器，匹配所有紧随E元素之后的同级元素F
CSS 2.1 属性选择器
E[att] 匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如"[cheacked]"。以下同。）
E[att=val] 匹配所有att属性等于"val"的E元素
E[att~=val] 匹配所有att属性具有多个空格分隔的值、其中一个值等于"val"的E元素
E[att|=val] 匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以"val"开头的E元素，主要用于lang属性，比如"en"、"en-us"、"en-gb"等等
CSS 2.1中的伪类
E:first-child 匹配某元素的第一个子元素是E的 
E:link  匹配所有未被点击的链接
E:visited 匹配所有已被点击的链接
E:hover  匹配鼠标悬停其上的E元素
E:active 匹配鼠标已经其上按下、还没有释放的E元素
E:focus 匹配获得当前焦点的E元素
E:lang(c) 匹配lang属性等于c的E元素
CSS 2.1中的伪元素
E:first-line 匹配E元素的第一行
E:first-letter 匹配E元素的第一个字母
E:before 在E元素之前插入生成的内容
E:after  在E元素之后插入生成的内容
CSS 3的同级元素通用选择器
E ~ F 匹配任何在E元素之后的同级F元素
CSS 3 属性选择器
E[att^="val"] 属性att的值以"val"开头的元素
E[att$="val"] 属性att的值以"val"结尾的元素
E[att*="val"] 属性att的值包含"val"字符串的元素
CSS 3中与用户界面有关的伪类
E:enabled 匹配激活的元素
E:disabled 匹配禁用的元素
E:checked 匹配表单中被选中的radio（单选框）或checkbox（复选框）元素
E::selection 匹配用户当前选中的元素
CSS 3中的结构性伪类
E:root 匹配文档的根元素，对于HTML文档，就是HTML元素
E:nth-child(n) 匹配其父元素的第n个子元素，第一个编号为1
E:nth-last-child(n) 匹配其父元素的倒数第n个子元素，第一个编号为1
E:nth-of-type(n) 与:nth-child()作用类似，但是仅匹配使用同种标签的元素
E:nth-last-of-type(n) 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素
E:last-child 匹配父元素的最后一个子元素，等同于:nth-last-child(1)
E:first-of-type 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)
E:last-of-type 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)
E:only-child 匹配父元素下仅有的一个子元素，等同于:
first-child:last-child或 :nth-child(1):nth-last-child(1)
E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素，
等同于:first-of-type:last-of-type
或 :nth-of-type(1):nth-last-of-type(1)
E:empty 匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素
CSS 3的反选伪类
E:not(s) 匹配不符合当前选择器的任何元素
CSS 3中的 :target 伪类
E:target 匹配文档中特定"id"点击后的效果
Transition
让状态变化有一个时间轴
引入transition之前，css所有的状态变化都是即时完成
transition：属性 动画进行时间 速率 延迟
transition-property:执行变换的属性
none: 马上停止执行transition
all:  任何属性值变化都将执行 
属性值：跟颜色有关 跟数字有关 等等 
并不是所有属性都能触发
transition-duration:变换延续的时间
transition-timing-function:变换速率的变换
ease(逐渐变慢，默认) linear(匀速) ease-in(加速) ease-out(减速) ease-in-out(加速然后减速) cubic-bezier 
transition-delay:属性值改变后多长时间开始执行transition 
delay的真正意义：指定了动画发生的顺序
使得多个不同的transition可以连在一起，形成复杂效果。
必须知道开始状态和结束状态的具体数值，不能用auto,否则不会产生动画效果。
局限：1.需要事件触发，没法在网页加载时自动触发。
      2.一次性的，不能重复触发
      3.只能定义开始和结束状态，不能定义中间状态
Transform
transform-origin设置对象变换的原点
2D情况下：默认值 50% 50% 
3D情况下：默认值 50% 50% 0
transform: rotate(45deg);
-ms-transform: rotate(45deg);     /* IE 9 */
-moz-transform: rotate(45deg);    /* Firefox */
-webkit-transform: rotate(45deg); /* Safari Opera and Chrome */ 
角度单位90deg度数 = 100grad = 0.25turn转、圈 ≈ 1.570796326794897rad弧度
对元素进行translate位移、rotate旋转、scale缩放、skew倾斜操作，支持2D或者3D转换，IE9+支持。
translate(x,y) 
translate3D(x,y,z)
translateX(): 指定X轴的位移;
translateY(): 指定Y轴的位移;
translateZ(): 指定Z轴的位移;
位移量的百分比是相对元素自身宽高来计算
translate有一个最常见的应用，即当元素宽度高度不固定时，使用translate可实现水平以及垂直方向的居中。
.item{
    position: absolute;
    top: 50%; /*相对于父级*/
    left: 50%;
    transform: translate(-50%, -50%); /*相对自身*/
}
rotate() rotate3D() rotateX() rotateY() rotateZ()
rotate值为正,顺时针
rotate(-45deg)==rotateZ(-45deg)==rotate3D(0,0,1,-45deg)
缩放：scale() scale3D() scaleX() scaleY() scaleZ()
参数值 大于1:放大  0～1:缩小  1:不变  0：元素不可见。
负数：元素相对于坐标轴发生反转，缩放效果没变
斜切：skew() skewX() skewY()
平行四边形 梯形 菱形 折角
transform3D 
perspective属性的存在与否决定了你所看到的是2次元的还是3次元的，也就是是2D transform还是3D transform.
没有透视，不成3D.
CSS3 3D transform的透视点是在浏览器的前方
translateZ的功能就是让元素在自己的眼前或近或远
当translateZ为正值的时候，元素会向其面对的方向走去；如果元素无旋转，就会朝显示器走来
perspective:2000px;
3D效果与在距屏幕2000px看到的效果一致
translateZ和perspective组合的效果
translateZ 越小 元素越小
translateZ =perspective 元素最大
translateZ > perspective 元素没了
perspective两种写法：
父辈元素
.stage{
perspective:2000px;
}
当前动画元素
.box{
transform:perspective(600px) rotateY(45deg)
}
perspective-origin：所看舞台或元素的中心
transform-style：preserve-3d（3D透视）/flat(平面) 应用在舞台元素上
旋转木马照片墙 
在父元素/舞台元素transform-style:preserve-3d
                  perspective:800px;
9张图片
让所有图片position：absolute 共用一个公共点
每个图片transform:rotateY 累加40度
拉开空间，每张图片向前走几步，将彼此之间的距离拉开
translateZ:175.8px;
让旋转木马转起来 让容器每次rotateY:40度
Animation
animation:一个周期持续的时间 动画名称 播放次数
div：hover{
animation:1s rainbow infinite;
动画一个周期持续的时间 动画效果的名称
animation: 1s rainbow 3; 具体播放的次数
animation-fill-mode:动画结束以后，默认从结束状态跳回到起始状态
none:回到动画没开始时的状态
forwards:保持在结束状态
backwards:动画回到第一帧的状态
both:根据animation-direction轮流应用forwards和backwards
animation-fill-mode:both，animation-direction才有用
animation-directionnormalalternate reverse alternate-reverse
animation-play-state:paused(让动画保持突然终止时的状态) running  
@-webkit-keyframes rainbow{ }
@keyframes rainbow{ 
0% { background: #c00; }
  50% { background: orange; }
  100% { background: yellowgreen;}
}
IndexedDB
var openRequest = indexedDB.open("test",1);
可能触发的三个事件：
upgradeneeded  success error blocked
openRequest.onsuccess = function(e) {
db = e.target.result;
}
db.createObjectStore("test", 
{ keyPath: "email"，autoIncrement:true }); 
store.createIndex("name","name",{unique:false});
store.createIndex("email","email", {unique:true});
db.objectStoreNames
var t = db.transaction(["firstOS"],"readwrite");
三个事件：complete abort error 
var store = t.objectStore("firstOS");
var request = store.add(o,1);
var ob = store.get(x);
var request = store.put(o, 1);
var request = store.delete(1);

var cursor = store.openCursor();
cursor.onsuccess = function(e) {
    var res = e.target.result;
    if(res) {
        console.log("Key", res.key);
        console.dir("Data", res.value);
        res.continue();
}
}
var index = store.index("name");
如果没有，get方法只能按照键名读取数据，而不能按照name属性读取数据。
var request = index.get(name);
var range = IDBKeyRange.bound('B', 'D');
index.openCursor(range)；

将大量数据储存在客户端，这样可以减少用户等待从服务器获取数据的时间。
Cookie 不超过4KB，且每次请求都会发送回服务器端
LocalStorage 在 2.5MB 到 10MB 之间
IndexedDB 就是浏览器端数据库。它允许储存大量数据，提供查找接口，还能建立索引。
IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。
键值对储存 异步 支持事务 同域限制 储存空间大 支持二进制储存
浏览器原生提供indexedDB对象
打开数据库：
var openRequest = indexedDB.open("test",1);（数据库名称 数据库版本）
打开一个名为test、版本为1的数据库。
如果该数据库不存在，则会新建该数据库。
如果省略第二个参数，则会自动创建版本为1的该数据库。
第一次打开数据库时，会先触发upgradeneeded事件，然后触发
success事件
upgradeneeded：第一次打开该数据库，或者数据库版本发生变化。
success：打开成功。
error：打开失败。
blocked：上一次的数据库连接还未关闭。
var db;
openRequest.onsuccess = function(e) {
    console.log("Success!");
db = e.target.result;
}
回调函数接受一个事件对象event作为参数，它的target.result属性就指向打开的IndexedDB数据库。
createObjectStore：用于创建存放数据的“对象仓库”，类似于表。
db.createObjectStore("firstOS");
创建了一个名为firstOS的对象仓库，如果该对象仓库已经存在，就会抛出一个错误。
第二个对象参数，用来设置“对象仓库”的属性。
keyPath属性表示，所存入对象的email属性用作每条记录的键名
db.createObjectStore("test", { keyPath: "email" }); 
autoIncrement属性表示，是否使用自动递增的整数作为键名
objectStoreNames属性返回一个DOMStringList对象，里面包含了当前数据库所有“对象仓库”的名称。
if(!db.objectStoreNames.contains("firstOS")) {
     db.createObjectStore("firstOS");
}
transaction方法用于创建一个数据库事务。
向数据库添加数据之前，必须先创建数据库事务。
var t = db.transaction(["firstOS"],"readwrite");
第一个参数是一个数组，里面是所涉及的对象仓库
第二个参数是一个表示操作类型的字符串，readonly（只读）和readwrite（读写）
transaction方法有三个事件，可以用来定义回调函数。
abort：事务中断。
complete：事务完成。
error：事务出错。
t.oncomplete = function(event) {
      // some code
};
transaction方法返回一个事务对象，
该对象的objectStore方法用于获取指定的对象仓库。
var store = t.objectStore("firstOS");
获取对象仓库以后，就可以用add方法往里面添加数据了。
var request = store.add(o,1);
add方法的第一个参数是所要添加的数据，第二个参数是这条数据对应的键名（key）
add方法是异步的，有自己的success和error事件，可以对这两个事件指定回调函数。
request.onsuccess = function(e) {
console.log("数据添加成功！");
}
读取数据使用get方法，它的参数是数据的键名。
var ob = store.get(x);
ob.onsuccess = function(e) {
	// ...
}
可以写成下面这样链式形式
db.transaction(["test"],"readonly").objectStore("test")
.get(X).onsuccess = function(e){}
更新记录：put方法
var request = store.put(o, 1);
删除记录：delete方法
var request = t.objectStore("people").delete(thisId);
遍历数据：openCursor方法
var cursor = store.openCursor();
回调函数接受一个事件对象作为参数，该对象的target.result属性指向当前数据对象。
openCursor方法还可以接受第二个参数，表示遍历方向，默认值为next，其他可能的值为prev、nextunique和prevunique。
后两个值表示如果遇到重复值，会自动跳过。
当前数据对象的key和value分别返回键名和键值（即实际存入的数据）。
continue方法将光标移到下一个数据对象
cursor.onsuccess = function(e) {
    var res = e.target.result;
    if(res) {
        console.log("Key", res.key);
        console.dir("Data", res.value);
        res.continue();
}
}
createIndex方法用于创建索引。
var store = db.createObjectStore("people", { autoIncrement:true });
store.createIndex("name","name",{unique:false});
store.createIndex("email","email",{unique:true});
第一个是索引名称，第二个是建立索引的属性名，第三个是参数对象，用来设置索引特性。unique表示索引所在的属性是否有唯一值。
index方法用于从对象仓库返回指定的索引。
var index = store.index("name");
var request = index.get(name);
如果没有指定索引的那一行代码，get方法只能按照键名读取数据，而不能按照name属性读取数据。
先用index方法指定索引在name属性上面，然后用get方法读取某个name属性所在的数据。
生成Range对象以后，将它作为参数输入openCursor方法，就可以在所设定的范围内读取数据。
var index = store.index("name");
var range = IDBKeyRange.bound('B', 'D');
index.openCursor(range).onsuccess = function(e) {}
lowerBound方法：指定范围的下限。
upperBound方法：指定范围的上限。
bound方法：指定范围的上下限。
only方法：指定范围中只有一个值。
// All keys <= x	
var r1 = IDBKeyRange.upperBound(x);
// All keys < x	
var r2 = IDBKeyRange.upperBound(x, true);
// All keys > x &&< y	
var r6 = IDBKeyRange.bound(x, y, true, true);
// The key = z	
var r9 = IDBKeyRange.only(z);
事件模型
部署EventTarget接口：window document element XMLHttpRequest
addEventListener：绑定事件的监听函数
addEventListener(事件名称,监听函数,捕获阶段触发)
添加多个，按顺序触发
多次添加同一个监听函数,只会执行一次
要传递参数,套一个匿名函数
document.addEventListener('click', hello, false);
el.addEventListener('click', function () { print('Hello'); }, false);
removeEventListener：移除事件的监听函数
必须和addEventListener参数完全一样，作用在同一个元素节点上
dispatchEvent：触发指定事件，从而触发监听函数执行
为事件绑定监听函数的三种方法
1.HTML标签的on属性 只会在冒泡阶段触发
on属性的值时将要执行的代码，不能光写个函数名，一定要加圆括号
监听函数部署在html标签的on属性上，this不会指向触发事件的元素节点
违反了HTML代码和js相分离的原则
div.onclick=function(){}; 只会在冒泡阶段
同一个事件只能定义一个监听函数
但所有浏览器都支持这两种方法
addEventListener的优点
指定多个监听函数
指定在捕获阶段或冒泡阶段触发监听函数
除了DOM节点，还可以部署在window XMLHttpRequest 等对象上面，统一了整个js的监听函数接口
事件传播的三个阶段：
捕获：从window对象传导到目标节点
目标：在目标节点上触发
冒泡：从目标节点穿回到window对象
用户点击，浏览器假定点击的是嵌套最深的节点
window document html body div
事件代理：事件在冒泡阶段向上传播到父节点，把监听函数定义在父节点上
只定义一个监听函数，就能处理多个子节点的事件
希望事件不往上传播：event.stopPropagation()
不会阻止其他监听函数
stopImmediatePropagation() 全阻止
事件发生以后会产生事件对象，作为参数传给监听函数
IE8及以下 window.event window.event.srcElement
new Event(事件名称，{bubbles,cancelable}) 
bubbles:当前事件是否会冒泡,只能在新建事件时改变,默认不冒泡
cancelable:事件是否可以取消，只能在新建事件时改变，默认不可取消 
eventPhase:事件目前所处的阶段
0 事件目前没有发生
1 捕获阶段 2 目标阶段 3 冒泡阶段 
defaultPrevented:事件是否调用过preventDefault()
currentTarget:事件当前所在的节点 等同于this
target:事件最初发生的节点
event.type 事件类型
event.detail event.timeStamp 毫秒时间戳
如何计算鼠标移动的速度
screenX screenY timeStamp
event.isTrusted 是真实用户还是脚本触发的
event.preventDefault():取消浏览器对当前事件的默认行为，前提cancelable为true
为文本输入框设置校验条件，如果用户的输入不符合条件就输不进去
e.charCode  e.preventDefault()/return false
Event构造函数只能指定事件名，不能绑定数据,CustomEvent可以
HTML5
1.新的DOCTYPE <!DOCTYPE html>
2.语义化 给图像添加标识
<figure>
<img/>
<figcaption><p>***</p></figcaption>
</figure>
3.<small>被重新定义 专指小字
4.link script 无需type
5.contenteditable 内容可编辑
本地存储 
语义的header 和footer
10 表单新增 required  表单提交会验证是否为空
6.<input type=”email”> 验证有效邮件结构
placeholder 占位符  用在文本框和文本域
获得焦点 提示为空 失去焦点并且内容为空，显示提示
autofocus 自动获取焦点
正则表达式 pattern 没有两边斜杠的正则表达式，表单提交的时候会验证
属性支持检测 
“pattern” in document.createElement(“input”)
15 mark 此标签包裹的字符串应该与用户当前的行动相关联
语义化后，div应该用在没有更好的元素的时候。
output元素用来显示部分计算
audio video
在video元素中显示控制条使用 controls
18.滑块
<input type=range name=range min=0 max=10 step=1/>
<output name="result"></output>
var f = document.forms[0];
var range = f['range']
input[type=range]:before { 
content: attr(min); 
padding-right: 5px;
 }
var o = document.createElement('input');
o.type = 'range'; 浏览器不支持range滑块
if ( o.type === 'range') 
localStorage ? (localStorage.rangeValue = range.value) : 浏览器不支持本地存储;
一些表单元素新增了form属性
如果是提交按钮，提交form值对应的表单。
如果是元素，form对应的表单提交时，他也会被提交
提交按钮身在form2,点击后却提交了form1
textarea都不在人家form里，form提交的时候还带着textarea
有提交性质的按钮比如type=submit/image
新增属性formaction/enctype/method/novalidate/target
如果通过具有这些属性的按钮提交表单，它的这些属性会覆盖form元素本身的属性。回车提交的时候也会有这种效果。通过js中form.submit()不会有这种效果
enctype:提交数据的编码格式 H5新增了一种编码格式可以传二进制
novalidate 不进行原生的数据验证 
target 表单提交到哪个浏览器上下文，_self _parent _top  _blank
当前 父级浏览器上下文 顶级浏览器上下文 新打开的空白页
盒子模型
每个HTML元素 矩形盒子
内容区 内边界 内边距 边框 外边距 外边界
包含块：最近的块级祖先框
width:左内边界到右内边界的距离
边框的宽度不能为负
padding百分数值按其父元素width计算

P标签不能包含块级元素，如果包含，他会先把自己结束掉

DOM模型
操作网页的接口
ELement 1 Attribute 2 Text 3 Comment 8 
Document 9 DocumentType 10 DocumentFragment 11
Node.nodeName /nodeType/nodeValue(text/comment节点)
Node.textContent 当前节点的文本内容
Node.ownerDocument:document对象。
nextSibling previousSibling parentNode parentElement
childNodes 动态集合
firstChild lastChild 
hasChildNodes是否有子节点
cloneNode 注意相同ID
appendChild 作为最后一个子节点插入,如果是现有的节点,该节点将从原有的位置移除
父节点.insertBefore(所要插入的节点,当前节点的子节点不能是后代节点)
如果是现有的节点,该节点将从原有的位置移除
结合nextSibling属性模拟insertAfter
removeChild(必须是子节点不能是非子节点的后代节点) 被移除的节点依然存在于内存之中
父节点.replaceChild(新节点,要被替换走的子节点)
contains参数是否为后代节点。
compareDocumentPosition二进制值
0 相同 1 不在同一个文档 2 参数在前 4 参数在后 8 参数包含当前节点 16 当前节点包含参数 
isEqualNode两个节点是否相等,相等的节点子节点相同。
normalize 清理Text子节点
两种节点的集合：NodeList和HTMLCollection。
typeof NodeList/HTMLCollection // "function"
Node.childNodes/document.querySelectorAll()
Node.childNodes动态    document.querySelectorAll静态
length属性和数字索引
Array.prototype.slice.call(div_list);
forEach.call(element.childNodes, function(child){
不要使用for...in循环去遍历NodeList实例对象,会将length属性也遍历进去，而且不保证顺序。
for (var item of list) {
item方法，数字索引,从零开始计数
document.links/forms/images HTMLCollection
HTMLCollection可以用元素的id name属性引用
document.myform===document.forms.myform;
HTMLCollection与NodeList的区别
HTMLCollectionm只能是Element节点
（2）HTMLCollectionm动态集合
（3）HTMLCollection用id属性或name属性，NodeList只能使用数字索引。
HTMLCollection item(数字索引,ID,name)，namedItem(ID,name)
都可以用方括号运算符代替,建议一律使用方括号
ParentNode接口
Element,Document,DocumentFragment节点
children:HTMLCollection Element子节点
firstElementChild lastElementChild childElementCount
ChildNode接口
Element,DocumentType,CharacterData
Elem.remove() 移除当前节点 replaceWith() 使用参数指定的节点，替换当前节点。 
before/after在当前节点的前面，插入一个同级节点。 
document节点
获取document节点
document,window.document,iframe节点的contentDocument
XMLHttpRequest的responseXML,ownerDocument
document.doctype==document.firstChild：当前文档类型DTD 
document.documentElement：<html>
document.defaultView：document对象所在window对象
document.body <body>
document.head <head>
document.activeElement当前文档获得焦点的元素
document.scripts
document.styleSheets：当前网页所有的样式表
document.documentURI(所有文档)/document.URL(HTML文档)
Node.baseURI(绝对路径)
document.domain
document.lastModified(最后修改的时间戳) 字符串不能比较
用Date.parse转化一下
document.location:URL
document.location.href 
document.location.protocol/host/hostname/port/pathname
search(?x=111)/hash/user/password/
document.location.assign() 跳转到另一个网址
document.location.reload(true(从服务器)/false(从缓存)) 
document.location.toString()=document.location.href
document.location = baidu.com 网页直接跳转
document.location = '#top' 自动滚动到锚点处
点击后退就可以回到前一个网页。
document.referrer来源/title/characterSet字符集
readyState:loading正在html代码，尚未完成解析/interactive正在加载页面资源/complete加载完成
document.implementation.hasFeature(“HTML”,”2.0”);
document.compatMode:CSS1Compat/BackCompat
设置了明确的DOCTYPE,compatMode的值都为CSS1Compat。
document.open() 清除文档，重新写入内容
document.close() 用于关闭document.open新建的文档
document.write() 内容会当做HTML代码解析
渲染中不会调用open，DOMContentLoaded后，先open再写入
querySelector/querySelectorAll不支持伪元素,伪类getElementsByTagName(p) HTML标签 
getElementsByClassName() 空格分隔 符合所有 顺序不重要
document.getElementsByName()
document.getElementById() 效率比querySelector高
document.elementFromPoint视口 最上层的元素 
document.createElement/createTextNode/createAttribute
node.setAttributeNode(a);
node.setAttribute(“me”,”value”);
document.createDocumentFragment() 不会重新渲染 性能好document.hasFocus() 是否有元素被激活

var nodeIterator = 
document.createNodeIterator(document.body);
var pars = [];
var currentNode;
while (currentNode = nodeIterator.nextNode()) {
  pars.push(currentNode);
}

document.createNodeIterator(根节点,节点类型)
NodeFilter.SHOW_ALL/SHOW_ELEMENT/SHOW_TEXT/SHOW_COMMENT
nodeIterator .nextNode()/previousNode()
treewalker=document.createTreeWalker(根节点,节点类型);
treewalker.nextNode() treewalker.currentNode;
document.importNode(节点，深/浅拷贝) 拷贝外部节点
不会把原来的节点删掉
Js模块
为啥要用模块，方便呗，想用什么功能就加载什么模块
不用自己挨个写了
模块写的时候一定要遵循规范
要不一个人一套写法，大家没法用了
还有就是
模块尽量别跟程序的其他部分有交互，需要用到什么，就当成参数传进去。别混着用
如果是咱们自己写模块的话：
var module =（function($){
var m1=function(){};
var m2=function(){};
return {m1:m1,m2:m2};
}）(jQuery);
两个规范 AMD CommonJS
CommonJS同步不适用于浏览器端
AMD 异步 适用于浏览器端，不会造成网页性能问题
实现AMD require.js
预先处理一下各模块
require.config({
baseUrl:***,
paths:{
   键：路径，
键：路径
},
shim:{  定义一下那些不规范的模块，输出和依赖
   模块:{
 deps:[],
 export:***
}
}
});
require([模块一，模块二]，function(mod1,mod2){
依赖于这两个模块的代码写在回调函数中
});
define([m1,m2],function(m1,m2){
var m3=function(){};
return {m3:m3};
});
怎么导入require.js
去官网下啊亲，然后在<script src=require.js defer async data-main=main.js>
main.js就是主模块入口 然后再main.js里面就可以写了
你依赖什么模块 
require([],function(){ 主方法写在回调函数里就可以了  })
下面说ES6新出的模块
AMD CommonJS 都只能在运行时才能加载模块，确定各模块的依赖关系和输入输出，es6模块静态化，编译时就能加载模块了，也能知道输入输出的变量了。
模块自动采用严格模式
模块输出 变量 函数 类
动态绑定 实时取到模块中的值
export var m = 1;
var m = 1;
export {m as n};
export function f() {};
function f() {}; 
export {f};
import {firstName as surname,lastName,year} from './profile';
import export 都得放在代码顶层
export default function () {
    console.log('foo');
}
import customName from './export-default';可以指定任意名字,不使用大括号。
export default 42;
export default本质是将该命令后面的值赋给default变量
同时输入默认方法和其他接口：
import _, { each, each as forEach } from 'lodash';
import语句与export语句写在一起。
export { foo, bar } from 'my_module';
web安全
http 无状态协议
服务器 set-cookie session-id识别用户
服务器把session-id和用户认证信息绑定记录
浏览器发cookie，服务器收到session-id,去记录查得到之前的状态信息。
sessionid被盗走,伪造你的身份进行恶意操作,使用难以推测的字符串
Cookie包含的字段：
Expires 不设置cookie只在当前会话有效
本地时间决定Cookie是否过期 不精确 max-age代替
domain path secure 
HttpOnly:不能被js读取,只用于服务器发送,防止XSS
修改cookie:key domain path
浏览器发请求自动附上Cookie
document.cookie 读全部 写一个
CSRF 跨站请求伪造
挟制用户在当前已登录的web应用程序上执行非本意攻击
用户刚访问网站不久，cookie还有效
黑客以广告引导受害者访问，网站自动发请求 目标网站黑客的参数
看不到cookie和响应的数据 保护数据改变的操作。
验证请求来源referer 依赖浏览器
黑客伪造不了的信息token 服务器验证
遍历a form
论坛黑客发网址 连接到自己网站才加token
XSS 多种多样 
跨站脚本，网站应用程序的安全漏洞攻击
恶意用户将代码注入网页，HTML及脚本
攻击脚本通过输入 富文本编辑 改变页面显示或者数据库
最常见的就是 document.cookie
别在页面插不可信的数据，非得插就得好好编码
html attr script CSS url编码
闭合
Cookie httponly
浏览器端和服务器端验证输入
document.createTextNode() 返回的节点当做文本渲染，而不是HTML代码渲染,对大于号小于号进行转义,但不对单引号，双引号转义
textContent代替innerHTML 忽略节点内部的HTML标签，返回所有文本内容,自动对HTML标签转义,适合用户提供的内容。
Promise
Promise将各种内嵌回调的事务用流水形式表达，简化编程，让代码逻辑更加清晰。
异步编程的一种解决方案
里面保存着某个未来才会结束的事件
一个获取异步操作返回消息的对象
对象的状态不受外界影响
Pending(进行中) Fullfilled(已成功) Rejected（已失败）
只有异步操作的结果可以决定当前是哪一种状态
任何其它操作都无法改变这个状态
一旦状态改变就不会再变，任何时候都可以得到这个结果
只有两种状态改变：
Pending--Fullfilled
Pending--Rejected
只要这两种情况发生，状态就凝固了，不会再变,Resolved（已定型）
var promise = new Promise(function(resolve,reject){
//异步操作
if(异步操作成功){
resolve();
}else{
reject();
}
});
promise.then(function(value){},function(error){});
Promise新建后会立即执行
var getJSON = function(url) {
  	var promise = new Promise(function(resolve, reject){
    	var client = new XMLHttpRequest();
    	client.open("GET", url);
   	client.onreadystatechange = handler;
    	client.responseType = "json";
    	client.setRequestHeader("Accept","application/json");
      client.send();
      function handler() {
         if (this.readyState !== 4) {
             return;
         }
         if (this.status === 200) {
            resolve(this.response);
         }else {
            reject(new Error(this.statusText));
         }
       }
  });
  return promise;
};
getJSON("/posts.json").then(
function(json){
        console.log('Contents:'+json);
},function(error) {
        console.error('出错了', error);
}
);
如果调用resolve和reject函数时带有参数，那么参数会被传递给回调函数
P2 Resolve函数的参数可能是另一个promise实例（p1）
这时P2自己的状态无效，由p1的状态决定p2的状态
p1是pending时，p2的回调函数等待p1的状态改变
P1状态一变，p2的回调函数立即执行
then方法返回一个新的promise实例，因此可以采用链式的then,可以指定一组按照次序调用的回调函数。第一个回调函数完成以后，将返回结果作为参数，传入第二个回调函数
catch()===then(null,reject)
指定发生错误时的回调函数
如果promise的状态已经变成resolved,此时再手动抛出错误，catch是无法捕获的
promise对象的错误会一直向后传递，直到被捕获为止
建议总是使用catch捕获错误，不要使用then第二个参数，因为catch可以捕获前面then方法执行中的错误。
如果没有使用catch方法指定错误处理的回调函数，promise对象抛出的错误不会传递到外层代码。
catch方法返回的还是一个promise对象，因此后面还可以接着调用then方法。
如果没有报错，则会跳过catch()方法，直接执行后面的then方法。
var p=Promise.all([p1,p2,p3]);
将多个promise实例包装成一个新的Promise实例。
p1 p2 p3 的状态都变成fullfilled，p的状态才会变成fullfilled
p1 p2 p3的返回值组成一个数组，传递给p的回调函数
p1 p2 p3只要有一个状态是rejected,p的状态就会变成rejected
第一个被reject的实例的返回值，会传递给p的回调函数
只有所有的promise实例都变成fullfilled,或者其中一个变为rejected,才会调用Promise.all（）后面的回调函数
如果作为参数的promise实例自己定义了catch方法，那么它一旦被rejected,并不会触发Promise.all()的catch方法
var p = Promise.race([p1,p2,p3]);
将多个Promise实例包装成一个Promise实例
只要有一个实例率先改变状态，p的状态就跟着改变
率先改变的promise实例的返回值作为参数传递给p的回调函数
p=Promise.race([fetch()
,new Promise(function(resolve,reject){
setTimeout(()=>reject(new Error()),5000)})
]);
p.then(response=>console.log(response)).catch(error=>console.log(error));
5秒内fetch方法无返回结果，p状态变为rejected,从而触发catch方法指定的回调函数。
Promise.resolve()：将现有对象转化为promise对象
参数的四种可能：
1.promise实例:原封不动的返回这个实例
2.参数是一个具有then方法的对象
会将其转成Promise对象，并立即执行then方法
3.参数根本不是对象或参数不具有then方法
返回一个Promise对象，状态是resolved，回调函数立即执行，Promise.resolve()的参数会传递给回调函数
4.不带任何参数
直接返回一个resolved状态的Promise对象
Promise.reject()返回一个Promise实例，状态是rejected，回调函数会立即执行。参数会原封不动的作为reject的参数
高性能网站
使用尽量少的图片 用CSS代替文件
客户端验证出于性能和交互
服务器验证出于安全
HTML JS CSS 分离
Ajax技术 让页面的一小部分去响应用户的操作
使用本地存储
使用全球网络，云服务提供商使用户总是从他们附近的服务器获取，比DNS好。
事件种类
1.鼠标事件：click dblclick
先mousedown 然后mouseup 然后click
mousemove:在一个节点内部移动时触发
持续移动连续触发，所以要对监听函数做一些限定，一段时间内只能运行一次 setTimeout(function(){},时间)
mouseout:鼠标离开一个节点时触发 会冒泡
mouseleave:鼠标离开一个节点时触发
鼠标事件：new MouseEvent(事件名称，事件初始化对象);
事件初始化对象的一些属性：
1.ctrlKey shiftKey altKey metaKey
2.相对于屏幕screenX sceenY 
3.相对于窗口clientX clientY
4.button：按下了哪一个鼠标按键
-1 没有按键 0 左键 1 中间的键  2 右键
5.buttons:三位二进制,同时按下多个鼠标键
1(001) 主键   2(010) 右键    4(100) 中间的键
6.relatedTarget:次要相关节点
focusin：丧失焦点的节点 
focusout 接受焦点的节点
mouseenter mouseover 表示鼠标刚刚离开的节点
mouseleave mouseout 鼠标正在进入的节点
bubbles:是否冒泡 
cancelable:是否可取消 
detail:鼠标点击的次数
movementX movementY :当前位置与上一个mousemove事件之间的水平距离
var event = new MouseEvent(“click”,{
“bubbles”:true,
“cancelable”:false
});
elem.dispatchEvent(event);
2.mousewheel事件:在任何元素上触发，最终冒泡到document或window
事件属性：wheelDelta 向前滚动是120的倍数 向后滚动是-120的倍数 多数情况下，只要知道滚动方向就足够了。
opera9.5之前的版本wheelDelta正负号是颠倒的
怎么检测呢：client.engine.Opera&&client.engine.Opera<9.5
3.键盘事件：KeyboardEvent 继承MouseEvent
keydown
按下键盘任意键时触发，按住不放会重复触发
keypress 
按下键盘的字符键时触发 按住不放，重复触发
发生keypress事件意味着按下的键会影响到屏幕中文本的显示
keyup 
释放键盘上的键时触发
触发顺序：keydown keypress keyup
其中keydown keypress 在文本框发生变化之前触发
keyup在文本框已经发生变化之后触发
如果按住一个键不放，就会重复触发keydown和keypress
event.keyCode：发生keydown和keyup事件时
ASCII码中对应小写字母或数字的编码
event.charCode:对应keypress事件 键的ASCII编码
DOM3 key 文本字符 
文档事件：
1.beforeunload:在窗口将要关闭
这时在回调函数中调用
event.preventDefault()/event.returnValue=”只要非空”
就会自动跳出一个确认框，让用户确认是否关闭网页
浏览器兼容情况不好
2.pagehide:用户通过前进后退按钮离开当前页面时触发
将pagehide的event的persisted属性设为true,表示页面保存在缓存中，设为false,不保存在缓存中
unload:在beforeunload pagehide后面
定义unload事件的监听函数，页面不会保存在缓存中
5.DOMContentLoaded:
只生成了DOM,所有外部资源还没有下载结束
6.各种外部资源加载和Ajax请求，load成功error失败
7.网页加载触发顺序 DOMContentLoaded—>load—> pageshow
从缓存中加载时只有pageshow
pageshow事件有一个persisted属性，如果是第一次加载就是false,从缓存加载就是true
8.readyStateChange:发生在document对象和XMLHttpRequest对象上，当他们的readyState属性发生变化时触发
9.scroll事件：文档或文档元素滚动时触发,会连续大量的发生
监听函数之中不应该有非常耗费计算的操作
控制事件的触发频率
使用requestAnimationFrame或setTimeout
10.resize事件:在改变浏览器窗口大小时触发 
发生在window body frameset上，也会连续大量的触发
11.hashchange事件：URL的hash部分发生变化时触发
event.oldURL  event.newURL:表示变化前后的URL
焦点事件：发生在element节点和document对象上面
focus:获得焦点后触发，不冒泡
blur: 失去焦点后触发，不冒泡
focusin：获得焦点时触发 会冒泡
focusout：失去焦点时触发 会冒泡
target relatedTarget
表单事件：
input事件：input textarea contenteditable
2.select事件：input选中文本
3.change事件：input select textarea
Input,textarea值变化并且失去焦点
<select> 日期输入框 radio checkbox
4.reset表单重置 5.submit 表单提交
4.进度事件：ProgressEvent
XMLHttpRequest发出HTTP请求的过程，
<img><audio><video><style><link>加载外部资源的过程
下载和上传都会发生进度事件
进度事件有以下几种：
loadstart progress abort error timeout load  
loadend:可以用来取代load error abort 传输结束，成功失败未知
图片加载会在脚本运行前就完成，最好将一些事件（如error）的监听函数放在img元素的HTML属性中。保证发生加载错误时百分之百会执行
下载过程的进度事件
xhr.addEventListener("progress", updateProgress, false);
上传过程的进度事件，所有监听函数都要放在XMLHttpRequest. upload对象上面。
xhr.upload.addEventListener("progress",updateProgress,false
进度事件实例有以下属性：
lengthComputable:进度是否可计算
total:总长度 loaded
如果lengthComputable为false，total属性无法取得正确的值
5.拖拉事件：DragEvent
图片，链接，选中的文字
Element节点 draggabled=true
dragstart drag dragend
dragenter dragover dragleave drop
dragenter和dragover:阻止这两个事件的默认行为
DataTransfer 用来保存需要传递的数据
DataTransfer对象的属性：
1.dropEffect：放置行为 dragenter
copy move  link打开拖动的元素 none 不能把拖动的元素放到这里 
2.effectAllowed：允许哪种dropEffect dragstart
uninitialized none copy link move copyLink copyMove linkMove all
dropEffect只有搭配effectAllowed才有用
涉及文件event.dataTransfer.files
读取文件内容用FileReader对象
var reader=new FileReader();
reader.onload=function(){
content=reader.result
}
reader.readAsBinaryString(file);
dataTransfer.types:拖拉的数据格式
数据类型有：text/plain text/uri-list text/html等
dataTransfer两个方法：getData() setData()
getData(数据类型) setData(数据类型，具体数据) 
该类型数据不存在，写入，如果存在，该类型数据将被替换
clearData(数据类型)
setDragImage():拖动过程显示
setDragImage自定义图片，三个参数
img/canvas，鼠标相对于该图片左上角的横坐标和纵坐标
Touch事件：
identifier独一无二识别符
screenX screenY 触摸点屏幕左上角
clientX clientY 视口
pageX pageY 当前页面
radiusX radiusY rotationAngle 椭圆X轴Y轴 椭圆的旋转角度
force 0-1触摸压力
target 触摸发生的element节点
TouchList:三根手指 identifiedTouch(identifier) item(索引)
TouchEvent:
同时按下某个键 altKey ctrlKey metaKey shiftKey
changedTouches状态变化的 targetTouches触摸节点内活动状态 touches活动状态的
type: touchstart touchend touchmove touchcancel
函数的参数
函数不在乎你传进来多少个参数，也不在乎参数的类型
命名的参数只提供便利
arguments对象的长度由传入的参数个数决定，不由定义函数的命名参数个数决定
ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数
函数实际是对象
函数名仅仅是指向函数的指针
函数没有重载，声明两个同名函数，创建第二个函数时，实际上覆盖了第一个函数
函数声明和函数表达式：
函数声明提升：解析器会率先读取函数声明，并将它们放到源代码树的顶部，使其在执行任何代码之前可用。
函数表达式必须等到解析器执行到他所在的代码行，才会真正被解释执行。
要返回函数的指针而不执行函数，去掉函数后面那对圆括号
在函数内部两个特殊的对象 arguments this
arguments:类数组对象，包含着传入函数中的所有参数
arguments的callee属性指向拥有这个arguments对象的函数
function factorial(num){     if(num<=1) {         return 1;     }else{         return num*arguments.callee(num-1);     } }
无论引用函数时使用什么名字，都可以保证正常完成递归调用
this:引用的是函数据以执行的环境对象
caller保存着调用当前函数的函数引用,显示引用函数的源代码
在全局作用域中调用当前函数，它的caller为null
function outer(){
    inner();
} 
function inner(){
   alert(arguments.callee.caller);	
}
outer();
会显示outer的源代码，因为是outer调用了inner
函数的两个属性：length prototype
length:函数希望接收的命名参数的个数
每个函数都包含两个非继承而来的方法：apply  call 在特定的作用域中调用函数，实际上等于设置this的值
apply call真正强大的地方：在特定的作用域中调用函数,扩充函数赖以运行的作用域
apply：两个参数1.运行函数的作用域2.参数数组（Array函数或arguments对象）
call：传递给函数的参数可以单个传

toString.call(bar); //[object Array]
原型和原型链
每个函数都有的属性 
length(命名函数参数的个数) prototype(constructor:函数名)
构造函数唯一区别 使用new调用
原型：所有实例共享属性和方法
原型链：
构造函数的原型对象都包含指针指向构造函数
实例包含指向原型对象的内部指针
原型对象等于另一个类型的实例
原型对象包含指向另一个原型的指针
另一个原型包含指向另一个构造函数的指针
另一个原型又是另一个类型的实例
层层递进
原型搜索机制：读取某个对象的某个属性时，先搜对象实例，再搜索原型对象，再搜索superType.prototype。
创建自定义对象两种方式：
1.var person=new Object();
person.name=”lihanrui”;
2.var person={
name:lihanrui,
}；
属性类型：
数据属性：Configurable Enumerable Writable Value
访问器属性：Configurable Enumerable get set
Configurable:delete删除属性
Enumerable:for-in循环返回属性
Writable:修改属性的值
Object.defineProperty(对象，属性，{
writable:false,
value:”sss”
});
组合继承：
1.使用原型链实现对原型属性和方法的继承
2.使用构造函数实现对实例属性的继承
function SuperType(name){
this.name=name;
this.colors=[“red”，“blue”,”green”];
}
SuperType.protoType.sayName=function(){
alert(this.name);
}
function SubType(name,age){
执行SuperType()函数中定义的所有对象初始化代码
SubType每个实例都会有自己的colors属性副本
SuperType.call(this,name);
this.age=age;
} 
SubType.protoType=new SuperType();
原型式继承：共享引用类型值
var sub=Object.create(super,{name:{value:Greg}});
Bootstrap栅格
bootstrap的柵格系统，bootstrap就是靠这一套系统实现响应式的。响应式可以理解为同一个页面可以依据设备屏幕或浏览器窗口的大小自行适应布局
box-sizing的两个属性：
border-box：宽度高度设到边框
content-box：宽度高度设到内容
*{box-sizing:border-box;}内边距 边框不会增加它的宽度
.container {
  margin左右: auto; 居中
  padding左右: 15px; 留点边距
}
根据不同的设备宽度，为容器指定宽度 768 992 1200
@media(min-width: 768px) {
当宽度大于768px时触发
.container { width: 750px; }
}
.row {
  margin-right: -15px;
  margin-left: -15px;
}
总共有那么宽，Bootstrap分别将他们分割成12份
xs sm md lg 1至12 .col-xs-1
<div class="col-sm-10 col-md-8"></div>
<div class="col-sm-3 col-md-4"></div>
这两个div在小屏幕中会排2排 因为10+3>12 
所有的col{
  position: relative;
  min-height: 1px;
  padding-right: 15px;
  padding-left: 15px;
}
所有xs{
  float: left;
}
.col-xs-12 {
  width: 100%;
}
.col-xs-11 {
  width: 91.66666667%;
}
.col-xs-1 {
  width: 8.33333333%; }
@media (min-width: 1200px){
 /*各自列的实现*/       
}
Element
HTML标签元素 
不同标签 HTMLAnchorElement HTMLButtonElement
Element.attributes/id/tagName
innerHTML 包含& < >,读取时会转码，写入会解析成节点
outerHTML 赋值替换掉当前元素
className/classList
classList:add/remove/contains/toggle/item/toString
getBoundingClientRect().top/left 视口
getBoundingClientRect().left+scroll距网页
网页元素本身的高宽：
Element.getBoundingClientRect().width/height
Element.offsetHeight/offsetWidth
clientHeight和clientWidth:视觉面积 内容+padding
浏览器窗口的高和宽：
document.documentElement.clientWidth/clientHeight
IE6 quirks:document.body.clientWidth
必须在页面加载完成，否则document对象还没生成
滚动条滚过的长宽:每个元素scrollHeight和scrollWidth
Element.offsetParent:position不等于static 最近 上层元素
offsetTop offsetLeft:元素左上角距offsetParent左上角
1.元素的绝对位置：offsetLeft/offsetTop累加
元素的相对位置：绝对坐标减去页面滚动
document.documentElement.scrollLeft/scrollTop
2.相对位置：Element.getBoundingClientRect().left/top
绝对位置：Element.getBoundingClientRect().left/top+
document.documentElement.scrollLeft/scrollTop
children/childNodes
childElementCount===children.length
firstElementChild/lastElementChild/nextElementSibling/previousElementSibling
closest(CSS选择器) 本身或最近的父元素 
match(CSS选择器)
Element和document共有的四个方法
getElementsByTagName()
getElementsByClassName()
querySelector()
querySelectorAll()
Element.scrollIntoView()：true：顶部对齐 false尾部对齐
getBoundingClientRect() 视口 边框+padding
getClientRects():块级元素一个，行内元素占据多少行
当前元素在页面上形成的所有矩形
用于判断行内元素是否换行，以及行内元素的每一行的位置偏移
top,left，bottom,right,width,height
Element.insertAdjacentHTML(position，HTML字符串)
解析HTML字符串生成节点 
beforebegin/beforeend/afterbegin/afterend：元素节点的后面
Element.remove()/focus()
图片懒加载
图片占用网络资源,图片懒加载提高前端性能
图片滚入视窗，才真正加载。
路径放在其他属性，图片滚入视窗再把值放进src，赋完值自动加载所有没被加载的图片 class=lazyload
scroll resize添加监听函数
每次事件触发看有没有lazyload图片，有判断图片是否进入视窗，赋src，去掉lazyload属性。
timer && clearTimeout(timer); timer = setTimeout(function(){});
document.documentElement.scrollTop/clientHeight
getBoundingClientRect().top/bottom+scrollTop
jQuery的extend直接调用 $.imgLazyLoad()
(function($){
$.extend($,{         imgLazyLoad:function(){}
});
})($);
CSS使用技巧
单行文字：将行高与容器高度设为相等
多行文字：将行高设为容器高度的n分之一，n为行数
容器水平居中：{width:固定宽度;margin:0 auto;}
容器垂直居中：
大容器{position:relative}
小容器{height:240px;position:absolute;top:50%;
margin-top: - 自身高度的一半}
图片宽度自适应：img{max-width:100%;}
CSS优先性：
行内样式 1000
id样式 0100
class样式+属性选择+伪类 0010
标签名+伪元素0001
把!important放在所有后面，分号前面
所有的重要声明分一组
所有的非重要声明分一组
对外重要声明一定胜过非重要声明
通配符* 0000特殊性，继承值无特殊性
0特殊性比无特殊性强  所以不要随便用通配符
CSS层叠：后面覆盖前面，必须保证最下面的是最特殊的条件
LoveHate
String 基本包装类型的方法
charAt
charCodeAt 某位置的字符编码
concat 可以接收任意多个参数
slice/substring 开始位置,结束位置
substr 开始位置 字符个数  
slice 将负值与长度相加 substring 将负值转换为0
substr第一个参数加长度 第二个参数转换为0
indexOf/lastIndexOf 返回字符串的位置
trim() toUpperCase toLowerCase 
toLocaleUpperCase toLocaleLowerCase 针对地区
他们都不会改变原字符串
fromCharCode  接受一或多个字符编码将它们转化成字符串
console.log(String.fromCharCode(100,111,102,30));
localeCompare()字符串在字母表中排序,在参数之前负,地区决定排序结果
同源
协议域名端口全相同 cookie localStorage indexedDB DOM ajax
1.document.domain cookie DOM
set-cookie中指定为一级域名
iframe节点.contentWindow.document
window.parent.document
hash  onhashChange
3.window.postMessage():跨文档通信
event.data/source/origin 
接着给父窗口发消息 event.source.postMessage()
window.addEventListener('message', function(e) {
  console.log(e.data);
},false);
4.JSONP
createElement(script)
script.src=“callback=foo”
function foo(data){
}
把请求数据放在回调函数的参数位置传回来
无兼容问题
webSocket ws://wss:// 不实行同源政策
请求头信息origin,服务器判断是否允许
6.CORS 跨域资源共享
简单请求：请求方法 HEAD POST GET 
请求头 不超出几个字段
浏览器自动发CORS请求，在头信息增加一个源origin字段
服务器判断同不同意
origin不被允许，响应没有Access-Control-Allow-Origin
默认不包含cookie
想包含Access-Control-Allow-Credentials/xhr.withCredentials
非简单请求：
预检请求，请求方法是OPTIONS
Origin,HTTP方法，额外的头信息被不被允许
不被允许没有下列字段
服务器响应Access-Control-Allow-Origin/Methods/Headers
Access-Control-Max-Age:预检请求的有效期
在预检请求里服务器同意了，浏览器才会发出正式的XMLHttpRequest请求。
Window
window对象:浏览器窗口+顶层对象
全局变量 window的属性
window.name/opener/length总框架数
window.screenX/screenY：窗口相对于屏幕
window.innerHeight/innerWidth 
window.outerHeight/outerWidth:视口+滚动条+菜单+边框
window.pageXOffset/pageYOffset:滚动距离
window.navigator:浏览器信息
navigator.userAgent:浏览器厂商、版本
识别手机 /mobi/i.test(navigator.userAgent.toLowerCase())
navigator.plugins(插件)/platform(操作系统)/onLine
navigator.geolocation(Geolocation对象地理位置)
navigator.cookieEnabled:浏览器能否存储cookie
window.screen：设备信息 width/height:分辨率
window.moveTo()/moveBy() 
window.scrollTo/scrollBy()：向右向下滚动的像素
window.scrollBy(0,window.innerHeight)：向下滚一屏
window.open新建一个浏览器窗口 返回新窗口的引用
(url,名字,提示栏工具条等参数,是否替换history当前记录)
许多浏览器不允许脚本自动新建窗口,检查一下是否成功
window.close() 只对顶层窗口有效
window.print()/typeof window.print==”function”
window.focus()/getSelection():选中的文本
top/parent/self
<a target=_top></a> 在顶层窗口打开链接 _top _self _parent
父窗口和子窗口同源,iframe节点.contentWindow,iframe节点.contentDocument
没有父窗口 window.parent=window.self
window.frameElement返回父窗口中DOM节点
window.frames[0]是一个window对象
iframe元素id或name属性自动成为全局变量
<iframe id=myFrame></iframe> window.myFrame
name属性成为子窗口的名称,a标签/frame标签的target属性
window对象的事件：
load/error:js语言/js脚本/图像文件不存在,其他事件不会触发
如果脚本网址与网页网址不在同一个域，浏览器不会提供详细的出错信息
解决办法：在脚本所在的服务器Access-Control-Allow-Origin:*
script标签crossorigin=anonymous,读取文件不需要身份认证
URL编码：
语义字符：数字 字母 - _ . ! ~ * ‘’ ( )
元字符  ； ， / ? : @ & = + $ # 
除了以上字符，其他字符必须根据操作系统的默认编码转义，
%加两个大写的十六进制字母UTF-8
encodeURI()
encodeURIComponent()：元字符也会被转义 参数不会是整个URL
decodeURI()/decodeURIComponent() 还原转义后的URL
alert()/prompt()/confirm():堵塞效应,页面暂停执行
var result = prompt(“您的年龄是：”，25)；
点取消返回null,其他返回输入框的值 
弹出的对话框是浏览器统一规定的样式
window.closed:用来检查使用脚本打开的新窗口是否关闭
Text节点
document.createTextNode(“balabala”);
new Text(“balabala”);
Text节点.data=Text节点.nodeValue;
wholeText:将当前text节点与毗邻的text节点作为一个整体返回
length:文本长度
nextElementSibling：Text节点最近后面的同级Element节点
previousElementSibling
appendData()
deleteData(子字符串位置，子字符串长度)
insertData(插入位置，插入的子字符串)
replaceData(替换位置，被替换掉的长度，新加入的子字符串)
subStringData(开始位置，子字符串长度)
remove()：移除当前Text节点
splitText(分割位置) 分割到该位置的字符前结束
返回分割位置后方的字符串，原Text节点只包含分割位置前方的字符串
normalize()：将毗邻的两个text节点合并，在父元素调用
DocumentFragment：文档片段
操作DocumentFragment节点比直接操作DOM树快得多
document.createDocumentFragment()/new DocumentFragment()
DocumentFragment节点本身不能被插入当前文档。
当它作为appendChild()、insertBefore()、replaceChild()等方法的参数时，是它的所有子节点插入当前文档，而不是它自身。
一旦DocumentFragment节点被添加进当前文档，它自身就变成了空节点（textContent属性为空字符串），可以被再次使用。
如果想要保存DocumentFragment节点的内容，可以使用cloneNode方法。
children/firstElementChild/lastElementChild/childElementCount
三栏布局
html,body{
padding:0;
margin:0;
height:100%;
}
main,left,right{
height:100%;
}
编写html的时候不应该受制于CSS的干扰，所以main放前面left right放后面
圣杯布局：main left right
main left right float:left
main width：100%
left width:100px; margin-left:-100%
right width:200px; margin-left:-200px
body padding-left:100px padding-right:200px;
left position:relative;left:-100px;
right position:relative;right:-200px;  
双飞翼布局：main left right
<div class=main><div class=inner></div></div>
把内容都写到inner里
inner margin-left:100px; margin-right:200px;
浮动布局：left right main
left float:left width:100px
right float:right width:200px
main margin-left:100px margin-right:200px
绝对定位：left main right
left position:absolute left:0px top:0px
main margin-left:100px margin-right:200px top:0px
right position:absolute right:0px top:0px
link和@import
权重 加载先后 html与CSS
sessionStorage和localStorage
在浏览器端储存数据
sessionStorage:保存的数据用于浏览器的一次会话，会话结束窗口关闭，sessionStorage保存的数据就被清空。
localStorage:保存的数据长期存在。
比cookie能动用大得多的存储空间
Cookie 4KB
他俩 根据浏览器不同 2.5MB-10MB
他俩的方法都一样：
以键值对形式存在
setItem(key,value)
getItem(key)
removeItem(key)：清除某个键名对应的数据
clear()：清除所有保存的数据
遍历操作：
localStorage.key(数字索引)
localStorage.length
storage事件：
window.addEventListener(“storage”,处理函数)
event事件四个属性：
key oldValue newValue url
该事件不在导致数据变化的当前页面触发。
如果浏览器同时打开一个域名下面的多个页面，其中一个页面改变
sessionStorage或localStorage的数据时，其他所有页面的storage事件会被触发，而原始页面不会触发。可以通过这种机制，实现多个窗口之间的通信。
正则表达式：
在编译时新建正则表达式
var regex=/xyz/;
在运行时新建正则表达式
var regex=new RegExp(“xyz”);
正则对象的属性：
1.ignoreCase 
2.global 
3.multiline 
4.lastIndex  g修饰符时下一次开始搜索的位置
5.source 正则表达式的字符串形式
regex.test(str)   //true false
如果带有g,每一次test方法都从上一次结束的位置开始向后匹配
通过lastIndex指定开始搜索的位置，必须有g
lastIndex只对同一个正则表达式有效
正则模式是空串，匹配所有字符串
regex.exec(str) 返回匹配结果
正则表达式包含组匹配，返回的数组第一个成员是整个匹配成功的结果，后面的成员是圆括号对应的匹配成功的组
返回的数组有两个属性：input 原字符串 index 模式匹配成功的开始位置
包含g，exec搜索的位置从上一次匹配成功结束的位置开始
字符串对象的方法：
1.str.match(regex)：所有匹配的子字符串 
lastIndex对match无效
带有g 一次性返回所有匹配成功的结果
match的时候不要又用组匹配又用g，这样组匹配会被忽略
str.search(regex)：
匹配开始的位置 总是从头开始,lastIndex无效
3.str.replace(regex，str)：替换后的字符串 加g匹配所有 
消除字符串收尾两端的空格：str.replace(/^\s+|\s+$/g,””);
replace第二个参数$n
“hello world”.replace(/(\w+)\s(\w+)/,”$2$1”);
//world hello
$`匹配结果前面的文本 $’匹配结果后面的文本 
$&匹配的子字符串
“abc”.replace(‘b’,[$`-$&-$’])  //a[a-b-c]c
replace方法的第二个参数可以是函数
将每个匹配的内容替换为函数返回值
var a = "sdFhyGioJl".replace(/[A-Z]/g,function(match){    return "-"+match.toLowerCase(); }); console.log(a); //sd-fhy-gio-jl
替换函数可以接受多个参数，第一个是捕获到的内容，后面是捕获到的组匹配,倒数第二个参数是捕获到的内容在整个字符串中的位置，最后一个参数原字符串
4.str.split(regex,返回数组的最大成员数)：返回一个数组，分割后的各个成员
“a, b,c, d”.split(/, */,2);   [a,b]
如果带有组匹配，括号匹配的部分也会作为数组成员返回
“aaa*a*”.split(/(a*)/)  [“”,”aaa”,”*”,”a”,”*”]
元字符：
. 匹配除回车、换行、行分隔、段分割以外的所有字符
^ 字符串开始位置
$ 字符串结束位置
/^test$/ 从开始到结束只有test
| /11|22/  匹配11或22
有特殊含义的字符，如果要匹配他们本身，要加上反斜杠
\+ \^ \. \[ \] \$ \( \) \| \* \+ \? \{ \} \\\
如果使用new RegExp() 转义需要使用两个\\
\cX 相当于ctrl+[A-Z]
\b退格 \n 换行 \r 回车 \t制表 \v垂直制表 \f 换页 
\0 null \xhh 两位十六进制 \uhhhh 四位十六进制
[xyz]有一系列字符可供选择，只要匹配其中一个就好了
[^xyz]除了这个字符类中字符，其他字符都可以匹配
[^]匹配一切字符，包括换行符，比.好用
脱字符只有在第一个位置才有意义，否则就是字面意义
[a-c][0-9]连字符 必须在[]中   - 必须在头尾两个字符之间才有意义
预定义模式：
\d 相当于[0-9]  
\D 相当于[^0-9]
\w相当于[a-zA-Z0-9_] 任意字母数字下划线
\W相当于[^a-zA-Z0-9_]
\s相当于[\t\n\r\v\f]
\S相当于[^\t\n\r\v\f]
\b词的边界  
\B非词边界
/\bworld/.test(“hello-world”); //true
/\bworld/.test(“helloworld”); //false
[\S\s] 一切字符
重复类 {n}重复几次 {n,}至少重复几次  
{n,m}不少于n次，不多于m次
量词符 ? {0,1} * {0,} + {1，}
贪婪模式改为非贪婪模式 量词符后面加一个问号 +? *?
“aaa”.match(/a+?/); [“a”]
修饰符 g i m
/world$/.test(“world\n”); //false
/world$/m.test(“world\n”); //true
/^b/m.test(“a\nb”) //true
组匹配 test match
/(fred)+/.test(“fredfred”) true
“abcabc”.match(/(.)b(.)/); [abc,a,c]
/(.)b(.)\1b\2/.test(“abcabc”)  true
“hello world”.replace(/(\w+)\s(\w+)/,”$2$1”);
非捕获组：（?:x）不返回该组匹配的内容
“abc”.match(/(?:.)b(.)/);  [abc,c]
先行断言：x(?=y) x只有在y前面才匹配，y不记入结果
“abc”.match(/b(?=c)/); [b]
先行否定断言：x(?!y) x只有不在y前面才匹配，y不记入结果
download
当前浏览器是否支持download属性
download in document.createElement(“a”);
<a href="large.jpg" download>下载</a>
指定下载图片的文件名：
<a href="index_logo.gif" download="_5332_.gif">下载</a>
将文本或者JS字符串信息借助Blob转换成二进制，然后，作为<a>元素的href属性，配合download属性，实现下载。
var elem = document.createElement("a"); elem.download="lo"; var blob = new Blob(["这是一个晴朗的早晨"]); var ui = URL.createObjectURL(blob); elem.href=ui; document.body.appendChild(elem); elem.click();
Css变量
变量名前加两个连词线
body{
--foo:#888888;
}
var()用于读取CSS变量
color:var(--foo,#777777);第二个参数，表示变量的默认值
foo:var(--bar)’world’ 如果变量值是字符串可以与其他字符串拼接
如果变量值是数值，不能与数值单位直接连用，必须用calc()
margin-top:calc(var(--bar)*1px);
如果数值带单位就不能写成字符串
同一个css变量在多个选择器内声明，读取的时候取优先级最高的生效
变量的作用域：它所在选择器的有效范围
全局变量通常放在根元素中,确保任何选择器都可以读取它们
:root{
--foo:***;
}
对于不支持CSS变量的浏览器
渐进增强
a{
color:#676768;
color:var(--ad);
}
Array
生成新的数组：
var array = new Array(2);//length=2 [undefined,undefined]
var array = Array(2);等同于上面
参数是非正整数的数值会报错
多参数时，所有参数都是新成员
非数值参数是新成员
var arr = [1,2];
判断一个值是否为数组：
value instanceof Array
缺点：假定单一的全局执行环境，如果包含多个框架，存在两个以上不同版本的Array构造函数，从一个框架向另一个框架传入一个数组，就不行啦 
所以有了Array.isArray(arr)
typeof 只能显示Object
typeof 检测基本数据类型
instanceof 检测引用数据类型
所有引用类型都是Object的实例
引用类型：Object Array Date Regex Function 
typeof几种可能的值:undefined boolean string number object function
基本类型值不是对象，引用类型值都是Object实例。
自动创建的基本包装类型的对象，只存在于一行代码的执行瞬间
var a= new Number(123); console.log(typeof a);//object console.log(a instanceof Number);//true console.log(a instanceof Object);//true var b=Number(123); console.log(typeof b);//number console.log(b instanceof Number);//false console.log(b instanceof Object);//false

typeof是一个操作符
对未初始化和未声明的变量执行typeof都会返回undefined
valueOf() [1,2,3] 
toString() “1,2,3”  
改变原数组：
push() 返回新的数组长度 
pop() 返回被删除的元素
shift() 返回被删除的元素
unshift() 返回新的数组长度
reverse() 颠倒元素的顺序 返回改变后的数组
splice() 返回被删除的元素 (起始位置，被删除的个数，要被插入的新元素)
第二个参数为0:只是单纯的插入 
只有一个参数:将从参数位置一直删到最后，拆分成两个数组
sort()：按字符串的字典顺序排 先转成字符串再排
按自定义排：传一个函数 函数返回值大于零就交换位置
[].sort(function(a,b){
return a-b;
})
原数组不变：
concat() 返回合并的新数组 接受其他类型的数值作为参数
slice(起始位置，终止位置) 提取元素的一部分，返回一个新数组， 终止位置元素本身不包括在内 参数是负数表示倒数计数位置
将类似数组的对象转为真正的数组
Array.prototype.slice.call(document.querySelectorAll(“”)
或者arguments
map(function(item，index，array){}) 
所有成员依次调用一个函数 根据结果返回一个新数组
[].map.call(“abc”,function(a){
return a.toUpperCase();
//this指向第二个参数,如果有的话 arr
},arr);  // [‘A’,’B’,’C’]
forEach() 没有返回值 无法中断 
如果要中断用for
filter() 返回结果为true的新数组 
some() 返回true false 有一个数组成员返回true就是true 
every() 返回true false 所有数组成员返回true才是true
reduce(function（累计变量，当前变量，当前位置，原数组）{
 //...........
},累计变量的初值);
最终累计为一个值  
reduceRight() 
indexOf(给定元素，开始搜索的位置) 返回元素在数组中第一次出现的位置 
没有返回-1 内部使用===进行比较
lastIndexOf() 返回元素在数组中最后一次出现的位置
合并两个数组：
Array.prototype.push.apply(a,b)
为对象添加元素:
对象变得有length属性
var a = {a:1};
[].push.call(a,2)//{a:1,0:2,length:2}
push pop 后进先出 栈结构
unshift shift 先进先出 队列
join 用参数作为分隔符，默认为逗号
数组成员undefined null 转为空字符串
Array.prototype.join.call(“abc”,”-”); //a-b-c
concat也可以将对象合并为数组
[].concat.call({a:1},{b:2}); [{a:1},{b:2}]
渐进增强和优雅降级
.transition { 
/*渐进增强写法*/
-webkit-transition: all .5s; 
-moz-transition: all .5s;
-o-transition: all .5s; 
transition: all .5s; 
} 
.transition { 
/*优雅降级写法*/ 
transition: all .5s;
-o-transition: all .5s; 
-moz-transition: all .5s; 
-webkit-transition: all .5s;
 }
渐进增强和优雅降级这两个概念是在 CSS3 出现之后火起来的。由于低级浏览器不支持 CSS3，但是 CSS3 特效太优秀不忍放弃，所以产生了的一种解决方式在高级浏览器中使用CSS3，而在低级浏览器只保证最基本的功能。
渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。
优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。
渐进增强观点认为应关注于内容本身
优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。
History
window的对象
window.history
history.length
history.back()
history.forward()
history.go()
从浏览器缓存之中加载，不会重新要求服务器发送新的网页
if (!!(window.history && history.pushState)){
当前浏览器是否支持History API
HTML5新方法 
1.pushState(state,title,url) 
state:状态对象,作为参数传入popState的回调函数
url：必须同域
添加完这个新记录后，浏览器地址栏立刻显示新url，但不会跳转到新url，它只是成为浏览历史中的最新记录。
如果pushState的url参数，设置了一个新的锚点值（即hash），并不会触发hashchange事件
replaceState(state,title,url)：它修改浏览历史中当前纪录,把它替换掉
popstate事件：
history对象发生变化，触发popstate事件
pushState和replaceState不会触发该事件
只有用户点击前进后退按钮，或者js调用back(),forward(),go()时才会触发。
该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。
URLSearchParams API用于处理URL之中的查询字符串，即问号之后的部分。
has()：是否具有某个参数
get()：返回指定参数的第一个值
getAll()：返回一个数组，成员是指定参数的所有值
set()：设置指定参数
delete()：删除指定参数
append()：在查询字符串之中，追加一个键值对
toString()：返回整个查询字符串
var searchParams = new URLSearchParams(paramsString);
keys()：遍历所有参数名
values()：遍历所有参数值
entries()：遍历所有参数的键值对
searchParams.keys()
返回的都是Iterator对象
for (var key of searchParams.keys()) {
DOM的a元素节点的searchParams属性，就是一个URLSearchParams实例。
URLSearchParams还可以与URL接口结合使用。
var url = new URL(location);
var foo = url.searchParams.get('foo') || 'somedefault';
URLSearchParams实例可以当作POST数据发送，所有数据都会URL编码
1.innerHTML和innerText
<div>aaa<p>1233</p>bbb</div>
var div = document.querySelector("div"); console.log(div.innerText);

console.log(div.innerHTML);

innerHTML的转码
<div>aaa<p>1233<>&</p>bbb</div>

2.Localstorage
localStorage.setItem("a","1"); localStorage.setItem("b","2"); localStorage.setItem("c","4"); window.addEventListener("storage",function(event){    console.log(event.oldValue);    console.log(event.newValue);    console.log(event.key);    console.log(event.URL); },false);

localStorage.clear(); console.log(localStorage.length);

3.元素位置
.child{     width:2000px;     height:2000px;     padding:300px;     border:solid 150px black; } .parent{     padding: 53px; }
console.log(div.clientHeight); 2600 height+padding console.log(div.scrollHeight); 2600 height+padding console.log(div.offsetHeight); 2900 height+padding+border console.log(div.getBoundingClientRect().height); 
2900 height+padding+border console.log(div.clientLeft); 150 padding区相对于border最外 console.log(div.scrollLeft);  0 没滚动哇 console.log(div.offsetLeft);  53 border相对于当前视口 假如html padding设为100px,结果就是153 所以是相对于视口 console.log(div.getBoundingClientRect().left); 53 border相对于当前视口  假如html padding设为100px,结果就是153 所以是相对于视口
4.Json格式就是一种文本格式
XML格式
每个Json对象就是一个值，要么简单类型要么复合类型
简单类型只能有：字符串 数值（必须十进制）布尔值 null
复合类型只能有：数组 对象
字符串和对象的键名必须用双引号，不能用单引号
数组或对象最后一个成员的后面不能加逗号
ES5新增JSON对象，处理JSON格式的数据，有两个方法
JSON.stringify()  JSON.parse()
JSON.stringify() 将一个值转为字符串，这个值符合JSON格式，并且可以被JSON.parse()方法还原。
JSON.stringify("abc")  // ""abc""
字符串abc，被转成了""abc""。这是因为将来还原的时候，双引号可以让 JavaScript 引擎知道，abc是一个字符串，而不是一个变量名。
JSON.stringify(1)      // "1"
JSON.stringify(false)      // "false"
JSON.stringify({ name: "张三" })   //"{"name":"张三"}"
原始对象中，有一个成员的值是undefined、函数或 XML 对象，这个成员会被过滤。
var obj = {
  a: undefined,
  b: function () {}
};
JSON.stringify(obj) // "{}"
数组的成员是undefined、函数或 XML 对象，则这些值被转成null
var arr = [undefined, function () {}]; JSON.stringify(arr)  //[null,null]
正则对象会被转成空对象。
JSON.stringify(/foo/) // "{}"
JSON.stringify方法会忽略对象的不可遍历属性。
var obj = {};
Object.defineProperties(obj, {
'foo': {
  value: 1,
  enumerable: true
},
'bar': {
  value: 2,
  enumerable: false
}
});
JSON.stringify(obj); // "{"foo":1}"
JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。
var obj = {
  'prop1': 'value1',
  'prop2': 'value2',
  'prop3': 'value3'};
var selectedProperties = ['prop1', 'prop2'];
JSON.stringify(obj, selectedProperties);
// "{"prop1":"value1","prop2":"value2"}"
function f(key, value) {
  if (typeof value === "number") {
      value = 2 * value;
  }
  return value;
}
JSON.stringify({ a: 1, b: 2 }, f)// '{"a": 2,"b": 4}'
5.扩展运算符
扩展运算符（spread）是三个点（...），将一个数组转为用逗号分隔的参数序列。
将数组转为函数的参数
var args = [0, 1, 2];
f(...args);
function f(x, y, z) {
  // ...
}
Math.max(...[14, 3, 77])
// ES5的合并数组
arr1.concat(arr2, arr3);
// ES6的合并数组
[...arr1, ...arr2, ...arr3]
// ES5
a = list[0]
rest = list.slice(1)
// ES6
[a, ...rest] = list
只能放在参数的最后一位，否则会报错。
const [...butLast, last] = [1, 2, 3, 4, 5];  // 报错
扩展运算符还可以将字符串转为真正的数组。
正确识别32位的Unicode字符
[...'x\uD83D\uDE80y'].length // 3
background-size
cover:当较短的边等于容器的边时，停止缩放,背景图像有可能超出容器
contain:当较长的边等于容器的边时，停止缩放。背景图像始终被包含在容器内。
AVL 平衡二叉搜索树
任意一个结点的key，比它的左孩子key大，比它的右孩子key小；
任意结点的孩子结点之间高度差距最大为1；
class AVLNode {
  AVLNode left;
  AVLNode right;
  int height;
  int key;
  ArrayList<Object> values;
}
长度单位
绝对长度单位
英寸in   厘米cm    毫米mm     点pt     派卡pc
只有浏览器知道用来显示页面的显示器、所用的打印机或其他任何用户代理的所有细节时，这些单位才真正有用。
相对单位长度
em  ex  px
em:给定字体的font-size值
ex:所用字体中小写x的高度
很多用户代理的做法：取em的值，再取其一半作为ex值 
一些浏览器会在内部显示一个小写的x，并计算相应的像素值来确定其高度与此字符font-size值之比，从而试图确定给定字体的x高度。
脱离文档流
float：直到碰到其他的浮动元素或块级父元素 
position:absolute fixed
浮动元素之间不会彼此覆盖，但是可能会覆盖掉其他元素
清除浮动
在父元素上：
float:left right
position:absolute fixed
overflow:auto hidden scroll
display:inline-block table-cell table-caption table
在子元素后面加空块级元素,也可以在父元素上添加伪元素并且display:block，然后对他们clear:both
会使清除元素的上外边距边界刚好在该边上浮动元素的下外边距边界之下。
11 class 
class LikeButton{     render(){ } } var a=new LikeButton(); var b=new LikeButton(); console.log(a.render== b.render);//true
里面的方法是原型哎
在类的实例上面调用方法，其实就是调用原型上的方法
类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。
只要你的代码写在类或模块之中，就只有严格模式可用。
12 一个组件实例
/*把string整成dom*/ const createDOMFromString = (domstring)=>{     var div = document.createElement("div");     div.className="wrapper";     div.innerHTML=domstring;     return div; } class LikeButton{     constructor(){         this.state={isLike:false};     }     changeLike(){         const likeText = this.elem.querySelector(".like-text");         this.state.isLike=!this.state.isLike;         likeText.innerHTML=this.state.isLike?"取消":"点赞";     }     render(){         this.elem=createDOMFromString("<button class='like-button'>" +                 "<span class='like-text'>点赞</span>" +                 "<span></span>" +                 "</button>");         this.elem.addEventListener("click",this.changeLike.bind(this),false);         return this.elem;     } } const wrapper = document.querySelector("body"); const likeButton1 = new LikeButton(); wrapper.appendChild(likeButton1.render());
13 MVC
Model模型 数据层 程序需要操作的数据和信息
View 视图 最上面的一层，用户的操作界面，程序的外壳
Controller 控制层 业务逻辑 根据视图层的指令，选取数据层中的数据，进行相应的操作
MVP Presenter
View和Model不发生联系,都通过Presenter传递
MVVM ViewModel view的变动自动反映在ViewModel
14.深拷贝和浅拷贝：
基本类型是按值传递，在修改a时并不会改到b
var a = 25;
var b = a;
b = 18;
但对象就不同，对象传的是按引用传值：
var obj1 = { a: 10, b: 20, c: 30 };
var obj2 = obj1;
复制一份obj1叫做obj2，然后把obj2.b改成100，但却不小心改到obj1.b，因为他们根本是同一个对象，这就是所谓的浅拷贝。
要避免这样的错误发生就要写成这样：
var obj1 = { a: 10, b: 20, c: 30 };
var obj2 = { a: obj1.a, b: obj1.b, c: obj1.c };

浅拷贝和深拷贝的区别就是共不共享内存
浅拷贝只复制指向对象的指针，不复制对象本身，新旧对象共享内存。
深拷贝新对象跟原对象不共享内存，修改新对象不会改到原对象。
浅拷贝的实现方式
Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。
关于Object.assign()是深拷贝还是浅拷贝的问题：
第一个参数是浅拷贝，它和Object.assign的返回结果共享内存，但后面的参数都是深拷贝。
var target = { a: 1 }; var source1 = { b: 2 }; var source2 = { c: 3 }; var a = Object.assign(target, source1, source2); console.log(target==a);//true
target // {a:1, b:2, c:3}
深拷贝
1.JSON.stringify JSON.parse
用JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象。
这种方法能正确处理的对象只有 Number, String, Boolean, Array, 扁平对象，即那些能够被 json 直接表示的数据结构。
直接使用var newObj = Object.create(oldObj)，可以达到深拷贝的效果。
递归拷贝

15.css的布局模型： 4.1 流动模型（flow）（默认的布局）：块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，以行的形式占据，内联元素都会在所处的包含元素下从左到右水平分布显示。 4.2 浮动模型（float）：使用float，让块状元素并排在一行显示。（浮动框脱离普通的文档流）
word-wrap
normal：

break-word:

Word-break
Normal:

Break-all:

Keep-all:

function a(){     for(var i=0;i<10000;i++){}     console.log(1); } function b(){     console.log(2); } setTimeout(a,0); setTimeout(b,0);
//1  2
同步转异步 把这两个方法塞进任务队列的最后
var a = 100; function func(){     console.log(a);     var a=200;     console.log(a); } func();
//undefined  200
因为预加载把全局变量a和局部变量a都设为undefined，当执行到func的第一个console时，在局部变量a的作用域链内查找a的值，因为局部变量的a已经有undefined值了，就不会再向上搜索作用域链了，所以第一个输出undefined
JS变量类型是松散型，松散型的意思并不是说JS变量就没有变量类型，而是其变量类型是在运行时才进行确定。
函数声明提升就说明JS在运行之前还会经历另外一个过程：预加载。
函数运行环境就是指：读取变量定义并确定其属于哪个作用域，但不会为其赋值！
JS分为预加载和执行期两个阶段，前者只会确定变量的作用域，在执行期才会对其进行赋值，同时也就确定了变量的具体类型。
两种数据类型的存储方式在JS中也有所不同。
内存分为栈区（stack）和堆区（heap），然后在JS中开发人员并不能直接操作堆区，堆区数据由JS引擎操作完成


变量标示：比如上图中的Str，变量标示存储在内存的栈区
变量值：比如上面中的Str的值souvenir或者是obj1对象的指向堆区地址，这个值也是存储在栈区
对象：比如上图中的对象1或者对象2，对象存储在堆区
对于基本数据类型来说，只使用了内存的栈区。
var a=100; var obj1={     attr:'hello' }; func(a,obj1); function func(num,obj){     var a2=num;     a2=200;     var obj2=obj;     obj2.attr='haha'; } console.log(a); console.log(obj1.attr);
obj2与obj实际上已经指向了同一个堆区的对象，然后obj2修改了这个对象的某个属性值。
for (var i = 0; i < 3; i++) {     setTimeout(function() {          console.log(i);      }, 0);      console.log(i); }  // 0 1 2 3 3 3
for (var i = 0; i < 3; i++) {     setTimeout((function(i) {         return function() {             console.log(i);         };     })(i), 0);  //改为立即执行的函数     console.log(i); }  // 0 1 2 0 1 2
console.log(' %s + %s = %s', 1, 1, 2) //1 + 1 = 2
%s 字符串      %d 整数           %i 整数  %f 浮点数  
%o 对象的链接  %c  CSS格式字符串

console.log('%cThis text is styled!',
  'color: red; background: yellow; font-size: 24px;')

console.log({foo: 'bar'})

console.warn({foo: 'bar'})

console.error({foo: 'bar'})

var languages = [     { name: "JavaScript", fileExtension: ".js" },     { name: "TypeScript", fileExtension: ".ts" },     { name: "CoffeeScript", fileExtension: ".coffee" } ]; console.table(languages);

var languages = {     csharp: { name: "C#", paradigm: "object-oriented" },     fsharp: { name: "F#", paradigm: "functional" } }; console.table(languages);

function greet(user) {     console.count();     return 'hi ' + user; } greet('bob'); greet('alice'); greet('bob');

function greet(user) {     console.count(user);     return 'hi ' + user; } greet('bob'); greet('alice'); greet('bob');

console.dir({f1: 'foo', f2: 'bar'})

console.assert(list.childNodes.length < 500, '节点个数大于等于500')
如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。
time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称
console.time('Array initialize'); var array= new Array(1000000); for (var i = array.length - 1; i >= 0; i--) {     array[i] = new Object(); }; console.timeEnd('Array initialize');
//Array initialize: 366.4619140625ms
MVC模式的意思是，软件可以分成三个部分。
视图（View）：用户界面。
控制器（Controller）：业务逻辑
模型（Model）：数据保存
View 传送指令到 Controller
Controller 完成业务逻辑后，要求 Model 改变状态
Model 将新的数据发送到 View，用户得到反馈
MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。
1. 各部分之间的通信，都是双向的。
2. View 与 Model 不发生联系，都通过 Presenter 传递。
3. View 非常薄，不部署任何业务逻辑，称为"被动视图"（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。
<meta name="viewport" content="width=device-width, initial-scale=1" />
viewport是网页默认的宽度和高度
width=device-width：网页宽度默认等于屏幕宽度
initial-scale=1：原始缩放比例为1.0，网页初始大小占屏幕面积的100%。
由于网页会根据屏幕宽度调整布局，所以不能使用绝对宽度的布局，也不能使用具有绝对宽度的元素。
具体说，CSS代码不能指定像素宽度，只能指定百分比宽度，width: xx%;或width:auto;
字体也不能使用绝对大小（px），而只能使用相对大小（em）。
如果一个元素的font-size:14px，那么对于该元素，1em等于14像素
body { 　　　　font: normal 100% Helvetica, Arial, sans-serif; 　　}
字体大小是页面默认大小的100%，即16像素。
h1 { 　　　　font-size: 1.5em;  　　}
h1的大小是默认大小的1.5倍，即24像素（24/16=1.5）。

float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。

"自适应网页设计"的核心，就是CSS3引入的Media Query模块
自动探测屏幕宽度，然后加载相应的CSS文件。
<link rel="stylesheet" type="text/css" 　　　　media="screen and (max-device-width: 400px)" 　　　　href="tinyScreen.css" />
如果屏幕宽度小于400像素（max-device-width: 400px），就加载tinyScreen.css文件。

除了用html标签加载CSS文件，还可以在现有CSS文件中加载。
@import url("tinyScreen.css") screen and (max-device-width: 400px);
同一个CSS文件中，也可以根据不同的屏幕分辨率，选择应用不同的CSS规则。
@media screen and (max-device-width: 400px) {
　　.column { 　　　　float: none; 　　　　width:auto; 　　}
　　#sidebar { 　　　　display:none; 　　}
}
如果屏幕宽度小于400像素，则column块取消浮动（float:none）、宽度自动调节（width:auto），sidebar块不显示（display:none）

图片的自动缩放 　img { max-width: 100%;}

操作系统到底提供哪些字体
黑体：SimHei
宋体：SimSun
新宋体：NSimSun
仿宋：FangSong
楷体：KaiTi
仿宋GB2312：FangSongGB2312
楷体GB2312：KaiTiGB2312
微软雅黑：Microsoft YaHei （Windows 7开始提供）
CSS的font-family命令，指定了网页元素所使用的字体。
font-family: Georgia, "Times New Roman","Microsoft YaHei", 
"微软雅黑", STXihei, "华文细黑",serif;
（1）优先使用排在前面的字体。
（2）如果找不到该种字体，或者该种字体不包括所要渲染的文字，则使用下一种字体。
（3）如果所列出的字体，都无法满足需要，则让操作系统自行决定使用哪种字体。
font-family应该优先指定英文字体，然后再指定中文字体。否则，中文字体所包含的英文字母，会取代英文字体，这往往很丑陋。
为了保证兼容性，中文字体的中文名称和英文名称，应该都写入font-family。比如，"微软雅黑"的英文名称是Microsoft YaHei。
宋体是最常见的中文字体，如果没有指定字体，操作系统往往选择它来渲染。这种字体并不美观。
微软雅黑的美观度和清晰度都较好，可以作为网页的首选字体。
黑体比较粗，不应用于字号较小的文字。

变量的解构赋值
let [a, b, c] = [1, 2, 3];
可以从数组中提取值，按照对应位置，对变量赋值。
模式匹配，只要等号两边的模式相同，左边的变量就会被赋予对应的值。
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3
let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]
不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。
这种情况下，解构依然可以成功。
let [x, y] = [1, 2, 3];
x // 1
y // 2
let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
如果等号的右边不是数组，那么将会报错。
对于 Set 结构，也可以使用数组的解构赋值。
let [x, y, z] = new Set(['a', 'b', 'c']);
x // "a"

具有iterator接口，就可以用for...of循环遍历它的成员
for...in循环读取键名，for...of循环读取键值。
var arr = ['a', 'b', 'c', 'd'];
for (let a in arr) {
  console.log(a); // 0 1 2 3
for (let a of arr) {
  console.log(a); // a b c d

箭头函数
var f = v => v;
var f = function(v) {
  return v;
};
如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。
var f = () => 5;
// 等同于var f = function () { return 5 };
var sum = (num1, num2) => num1 + num2;
// 等同于var sum = function(num1, num2) {
  return num1 + num2;
};
如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。
var sum = (num1, num2) => {return num1 + num2;}
由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。
// 报错
let getTempItem = id => {id:id ,name:"Temp"};
// 不报错
let getTempItem = id => ({ id: id, name: "Temp" });
数据结构 Set 类似于数组，成员的值都是唯一的
Set 本身是一个构造函数，用来生成 Set 数据结构
Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。
const s = new Set([2,3,1,3,2,3,4,4,5,6,3,5]); console.log(s);// 2 3 1 4 5 6
console.log(s.size);//6

<ul>     <li></li>     <li></li>     <li></li> </ul> <script>     const s = new Set(document.querySelectorAll("ul li"));     console.log(s.size);//3 </script>
向Set加入值的时候，不会发生类型转换，所以5和"5"是两个不同的值
NaN不等于自身
两个对象总是不相等
set.add({});
set.add({});
set.size // 2

Set.prototype.constructor：构造函数，默认就是Set函数。
Set.prototype.size：返回Set实例的成员总数。
操作方法：
add(value)：添加某个值，返回Set结构本身。
delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
has(value)：返回一个布尔值，表示该值是否为Set的成员。
clear()：清除所有成员，没有返回值。
Array.from方法可以将 Set 结构转为数组
遍历操作
keys()：返回键名的遍历器
values()：返回键值的遍历器
entries()：返回键值对的遍历器
forEach()：使用回调函数遍历每个成员
Set的遍历顺序就是插入顺序
用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用
Set 结构没有键名，只有键值，所以keys方法和values方法的行为完全一致。
Set结构的实例的forEach方法，用于对每个成员执行某种操作，没有返回值
forEach方法的参数就是一个处理函数
扩展运算符（...）内部使用for...of循环，所以也可以用于 Set 结构。
扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。
let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)];
// [3, 5, 2]
扩展运算符和 Set 结构相结合，数组的map和filter方法就可以用于 Set 了
new Set([...set].map(x => x * 2))
使用 Set 可以很容易地实现并集、交集和差集。
// 并集
let union = new Set([...a, ...b]);
// 交集
let intersect = new Set([...a].filter(x => b.has(x)));
// 差集
let difference = new Set([...a].filter(x => !b.has(x)));
WeakSet 的成员只能是对象，而不能是其他类型的值。
const ws = new WeakSet();
ws.add(1)
// TypeError: Invalid value used in weak set
WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用
WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。
WeakSet 的成员是不适合引用的，因为它会随时消失。
ES6 规定 WeakSet 不可遍历。
对象只接受字符串作为键名
Map 数据结构。它类似于对象，也是键值对的集合，但是键的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
Object 结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现
const m = new Map();
const o = {p: 'Hello World'};
m.set(o, 'content')
m.get(o) // "content"
m.has(o) // true
m.delete(o) // true
m.has(o) // false
Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。
const map = new Map([
  ['name', '张三'],
  ['title', 'Author']]);
map.size // 2
map.has('name') // true
map.get('name') // "张三"
Set和Map都可以用来生成新的 Map
Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞的问题
我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。
map.size
set(key, value)
get(key)
has(key)
delete(key)
clear()
keys()：返回键名的遍历器。
values()：返回键值的遍历器。
entries()：返回所有成员的遍历器。
forEach()：遍历 Map 的所有成员。
Map 的遍历顺序就是插入顺序。
for (let key of map.keys()) {
  console.log(key);
}
const map = new Map([[1, 'one'],[2, 'two'],[3, 'three']]);
[...map]  // [[1,'one'], [2, 'two'], [3, 'three']]
